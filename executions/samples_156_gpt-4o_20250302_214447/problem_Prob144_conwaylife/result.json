{
    "code": "module TopModule (\n    input logic clk,\n    input logic rst_n,\n    input logic load,\n    input logic [255:0] data,\n    output logic [255:0] q\n);\n\n    logic [255:0] grid, next_grid;\n\n    // Calculate the next state of the grid\n    always @(*) begin\n        integer row, col, idx;\n        integer neighbors;\n        next_grid = grid;\n        \n        for (row = 0; row < 16; row = row + 1) begin\n            for (col = 0; col < 16; col = col + 1) begin\n                idx = row * 16 + col;\n                neighbors = 0;\n\n                // Count neighbors with toroidal wrapping\n                neighbors = grid[((row-1)%16)*16 + ((col-1)%16)] +\n                            grid[((row-1)%16)*16 + col] +\n                            grid[((row-1)%16)*16 + ((col+1)%16)] +\n                            grid[row*16 + ((col-1)%16)] +\n                            grid[row*16 + ((col+1)%16)] +\n                            grid[((row+1)%16)*16 + ((col-1)%16)] +\n                            grid[((row+1)%16)*16 + col] +\n                            grid[((row+1)%16)*16 + ((col+1)%16)];\n\n                // Apply rules\n                if (neighbors < 2 || neighbors > 3)\n                    next_grid[idx] = 0;\n                else if (neighbors == 3)\n                    next_grid[idx] = 1;\n                else\n                    next_grid[idx] = grid[idx];\n            end\n        end\n    end\n\n    // Sequential logic for updating the grid\n    always_ff @(posedge clk) begin\n        if (!rst_n) begin\n            grid <= 256'b0;\n        end else if (load) begin\n            grid <= data;\n        end else begin\n            grid <= next_grid;\n        end\n    end\n\n    // Output the current state of the grid\n    assign q = grid;\n\nendmodule",
    "test_results": {
        "num_mismatch": 5008,
        "passfail": "R"
    }
}