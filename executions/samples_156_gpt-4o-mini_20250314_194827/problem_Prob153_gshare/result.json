{
    "code": "module TopModule (\n    input logic clk,\n    input logic reset,\n    input logic [1:0] branch_outcome, // 00: not taken, 01: taken, 10: not taken, 11: taken\n    output logic prediction\n);\n\n    // Global History Register\n    logic [3:0] global_history; // 4-bit history register\n\n    // Pattern History Table (PHT)\n    logic [1:0] PHT [0:15]; // 16 entries, 2 bits each for 2-bit saturating counters\n\n    // Prediction logic\n    logic [1:0] pht_index;\n    logic [1:0] pht_value;\n\n    // Initialize PHT and global history on reset\n    always @(posedge clk) begin\n        if (reset) begin\n            global_history <= 4'b0000;\n            for (int i = 0; i < 16; i++) begin\n                PHT[i] <= 2'b00; // Initialize all entries to '00'\n            end\n        end else begin\n            // Update prediction based on global history\n            pht_index = global_history[3:0]; // Use lower bits of global history as index\n            pht_value = PHT[pht_index]; // Read current PHT value\n\n            // Prediction logic: if counter is 10 or 11, predict taken\n            prediction = (pht_value[1] == 1'b1);\n\n            // Update global history\n            global_history = {global_history[2:0], branch_outcome[1]}; // Shift in the latest outcome\n\n            // Training logic: update PHT based on actual outcome\n            if (branch_outcome == 2'b01) begin // Taken\n                if (pht_value != 2'b11) begin\n                    PHT[pht_index] = pht_value + 2'b01; // Increment counter\n                end\n            end else if (branch_outcome == 2'b00) begin // Not taken\n                if (pht_value != 2'b00) begin\n                    PHT[pht_index] = pht_value - 2'b01; // Decrement counter\n                end\n            end\n        end\n    end\n\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "C"
    },
    "iterations_used": 3
}