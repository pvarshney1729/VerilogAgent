{
    "code": "module pattern_timer (\n    input logic clk,\n    input logic reset,\n    input logic data,\n    input logic ack,\n    output logic [3:0] count,\n    output logic counting,\n    output logic done\n);\n\n    logic [3:0] delay;\n    logic [3:0] next_count;\n    logic [3:0] bit_counter;\n    logic [3:0] shift_reg;\n    logic detecting_pattern;\n    \n    // State machine for pattern detection and counting\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0000;\n            counting <= 1'b0;\n            done <= 1'b0;\n            detecting_pattern <= 1'b1;\n            bit_counter <= 4'b0000;\n            shift_reg <= 4'b0000;\n        end else begin\n            if (detecting_pattern) begin\n                // Shift in data to detect pattern 1101\n                shift_reg <= {shift_reg[2:0], data};\n                if (shift_reg == 4'b1101) begin\n                    detecting_pattern <= 1'b0;\n                    bit_counter <= 4'b0000;\n                end\n            end else if (bit_counter < 4'b0100) begin\n                // Shift in delay bits\n                delay[3 - bit_counter] <= data;\n                bit_counter <= bit_counter + 1;\n                if (bit_counter == 4'b0011) begin\n                    count <= delay; // Initialize count with delay value\n                    counting <= 1'b1;\n                end\n            end else if (counting) begin\n                if (count == 4'b0000) begin\n                    done <= 1'b1;\n                    counting <= 1'b0;\n                end else if (clk % 1000 == 0) begin\n                    count <= count - 1;\n                end\n            end\n        end\n    end\n\n    // Acknowledge handling\n    always @(posedge clk) begin\n        if (done && ack) begin\n            done <= 1'b0;\n            detecting_pattern <= 1'b1;\n        end\n    end\n\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "m"
    }
}