{
    "code": "module TopModule (\n    input logic clk,\n    input logic reset,\n    output logic [31:0] q\n);\n\n    logic [31:0] q_reg, q_next;\n\n    // Sequential logic for the LFSR with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            q_reg <= 32'h1;\n        end else begin\n            q_reg <= q_next;\n        end\n    end\n\n    // Combinational logic to calculate the next state of the LFSR\n    always @(*) begin\n        q_next[31] = q_reg[0] ^ q_reg[31]; // Feedback from tap at position 32\n        q_next[30] = q_reg[31];\n        q_next[29] = q_reg[30];\n        q_next[28] = q_reg[29];\n        q_next[27] = q_reg[28];\n        q_next[26] = q_reg[27];\n        q_next[25] = q_reg[26];\n        q_next[24] = q_reg[25];\n        q_next[23] = q_reg[24];\n        q_next[22] = q_reg[0] ^ q_reg[23]; // Feedback from tap at position 22\n        q_next[21] = q_reg[22];\n        q_next[20] = q_reg[21];\n        q_next[19] = q_reg[20];\n        q_next[18] = q_reg[19];\n        q_next[17] = q_reg[18];\n        q_next[16] = q_reg[17];\n        q_next[15] = q_reg[16];\n        q_next[14] = q_reg[15];\n        q_next[13] = q_reg[14];\n        q_next[12] = q_reg[13];\n        q_next[11] = q_reg[12];\n        q_next[10] = q_reg[11];\n        q_next[9]  = q_reg[10];\n        q_next[8]  = q_reg[9];\n        q_next[7]  = q_reg[8];\n        q_next[6]  = q_reg[7];\n        q_next[5]  = q_reg[6];\n        q_next[4]  = q_reg[5];\n        q_next[3]  = q_reg[4];\n        q_next[2]  = q_reg[0] ^ q_reg[3]; // Feedback from tap at position 2\n        q_next[1]  = q_reg[0] ^ q_reg[2]; // Feedback from tap at position 1\n        q_next[0]  = q_reg[1];\n    end\n\n    // Assign the output\n    assign q = q_reg;\n\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "T"
    }
}