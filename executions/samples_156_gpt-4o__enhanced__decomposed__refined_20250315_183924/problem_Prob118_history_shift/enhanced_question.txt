
I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.

 - input  clk
 - input  areset
 - input  predict_valid
 - input  predict_taken
 - input  train_mispredicted
 - input  train_taken
 - input  train_history   (32 bits)
 - output predict_history (32 bits)

The module should implement a 32-bit global history shift register,
including support for rolling back state in response to a pipeline flush
caused by a branch misprediction. When a branch prediction is made
(predict_valid = 1), shift in predict_taken from the LSB side to update
the branch history for the predicted branch. (predict_history[0] is the
direction of the youngest branch.) When a branch misprediction occurs
(train_mispredicted = 1), load the branch history register with the
history after the completion of the mispredicted branch. This is the
history before the mispredicted branch (train_history) concatenated with
the actual result of the branch (train_taken). If both a prediction and
misprediction occur at the same time, the misprediction takes precedence,
because the pipeline flush will also flush out the branch that is
currently making a prediction. predict_history is the value of the branch
history register. areset is a positive edge triggered asynchronous reset
that resets the history counter to zero. Assume all sequential logic is
triggered on the positive edge of the clock.

Here is the enhanced specification which might be useful to you:
                **

**Module Name:**
- `TopModule`

**Interface:**
- **Inputs:**
  - `input logic clk` : Clock signal, positive edge triggered for all sequential logic.
  - `input logic areset` : Asynchronous reset, active high. Resets all registers to zero on the positive edge.
  - `input logic predict_valid` : Indicates a valid branch prediction request.
  - `input logic predict_taken` : The result of the branch prediction, to be shifted into history.
  - `input logic train_mispredicted` : Indicates a branch misprediction has occurred and requires updating history.
  - `input logic train_taken` : Actual result of the mispredicted branch.
  - `input logic [31:0] train_history` : The branch history just before the mispredicted branch.
- **Outputs:**
  - `output logic [31:0] predict_history` : The current state of the branch history.

**Behavior:**
- On the positive edge of `clk`:
  - **If** `areset` is high, reset `predict_history` to `32'b0`.
  - **Else if** `train_mispredicted` is high:
    - Load `predict_history` with `{train_history[30:0], train_taken}`.
  - **Else if** `predict_valid` is high:
    - Shift `predict_history` left by one, inserting `predict_taken` into the LSB: `{predict_history[30:0], predict_taken}`.

**Timing and Precedence:**
- `areset` is prioritized over all other signals due to its asynchronous nature.
- If both `train_mispredicted` and `predict_valid` are high in the same cycle, the misprediction logic takes precedence.

**Implementation Notes:**
- All registers and flip-flops are initialized to zero upon `areset`.
- Ensure all signal transitions occur on the positive edge of `clk` to maintain synchronous operation except for `areset`.
- Input and output signals are treated as unsigned logic vectors unless specified otherwise.

**Boundary Conditions:**
- The design assumes no simultaneous assertion of `areset` and other logic signals for normal operation.
- The behavior for simultaneous `predict_valid` and `train_mispredicted` is explicitly handled by prioritizing `train_mispredicted`.

**End of Enhanced Specification**

**
                