
I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.

 - input  clk
 - input  resetn
 - input  r (3 bits)
 - output g (3 bits)

The module should implement the FSM described by the state diagram shown
below:

  A        --r0=0,r1=0,r2=0--> A
  A        -------r0=1-------> B
  A        -----r0=0,r1=1----> C
  A        --r0=0,r1=0,r2=0--> D
  B (g0=1) -------r0=1-------> B
  B (g0=1) -------r0=0-------> A
  C (g1=1) -------r1=1-------> C
  C (g1=1) -------r1=0-------> A

Resetn is an active-low synchronous reset that resets into state A. This
FSM acts as an arbiter circuit, which controls access to some type of
resource by three requesting devices. Each device makes its request for
the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either
_r[0]_, _r[1]_, or _r[2]_. Each r[i] is an input signal to the FSM, and
represents one of the three devices. The FSM stays in state _A_ as long
as there are no requests. When one or more request occurs, then the FSM
decides which device receives a grant to use the resource and changes to
a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an
output from the FSM. There is a priority system, in that device 0 has a
higher priority than device 1, and device 2 has the lowest priority.
Hence, for example, device 2 will only receive a grant if it is the only
device making a request when the FSM is in state _A_. Once a device, _i_,
is given a grant by the FSM, that device continues to receive the grant
as long as its request, _r[i]_ = 1.

Implement a module that represents this FSM. Use separate always blocks
for the state table and the state flip-flops, as done in lectures.
Describe the FSM outputs, _g[i]_, using either continuous assignment
statement(s) or an always block (at your discretion). Assign any state
codes that you wish to use. Assume all sequential logic is triggered on
the positive edge of the clock.

Here is the enhanced specification which might be useful to you:
                #### Module Interface:
```verilog
module TopModule(
    input wire clk,          // Clock input
    input wire resetn,       // Active-low synchronous reset
    input wire [2:0] r,      // 3-bit request input vector, r[0] is highest priority
    output reg [2:0] g       // 3-bit grant output vector, g[0] corresponds to r[0]
);
```

#### Timing and Reset Behavior:
- **Clock**: All sequential logic is triggered on the positive edge of `clk`.
- **Reset**: `resetn` is an active-low synchronous reset. When `resetn` is low, the FSM transitions to state `A`, and all `g[i]` outputs are set to `0`.

#### FSM Description:
- **States**: The FSM has four states: `A`, `B`, `C`, and `D`.
  - State `A`: Idle state, no grants are active.
  - State `B`: Grant to device 0 (`g[0]=1`).
  - State `C`: Grant to device 1 (`g[1]=1`).
  - State `D`: Grant to device 2 (`g[2]=1`).

- **State Transitions**:
  - From state `A`: 
    - If `r[0] == 1`, transition to `B`.
    - Else if `r[1] == 1`, transition to `C`.
    - Else if `r[2] == 1`, transition to `D`.
    - Else remain in `A`.
  - From state `B`: 
    - If `r[0] == 1`, remain in `B`.
    - Else transition to `A`.
  - From state `C`: 
    - If `r[1] == 1`, remain in `C`.
    - Else transition to `A`.
  - From state `D`: 
    - If `r[2] == 1`, remain in `D`.
    - Else transition to `A`.

- **Outputs**: 
  - `g[i]` is set to `1` when in the corresponding state `B`, `C`, or `D`.
  - In state `A`, all `g[i]` outputs are `0`.

#### Implementation Notes:
- **State Encoding**: Use binary or one-hot encoding as preferred.
- **Always Blocks**: 
  - Use one always block for state transitions (sensitive to `clk` and `resetn`).
  - Use a separate always block or continuous assignments to derive `g` outputs based on the current state.
  
- **Priority Resolution**: Explicitly handled by state transition logic, with `r[0]` having the highest priority, followed by `r[1]`, and then `r[2]`.

- **Edge Cases**: Simultaneous requests are resolved by priority encoded in the state transition logic.

```verilog
// Example Verilog Implementation
always @(posedge clk or negedge resetn) begin
    if (!resetn) begin
        current_state <= A;
    end else begin
        case (current_state)
            A: if (r[0]) current_state <= B;
               else if (r[1]) current_state <= C;
               else if (r[2]) current_state <= D;
               else current_state <= A;
            B: if (!r[0]) current_state <= A;
            C: if (!r[1]) current_state <= A;
            D: if (!r[2]) current_state <= A;
        endcase
    end
end

always @(current_state) begin
    g = 3'b000;
    case (current_state)
        B: g[0] = 1;
        C: g[1] = 1;
        D: g[2] = 1;
    endcase
end
endmodule
```
                