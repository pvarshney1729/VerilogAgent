
I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.

 - input  clk
 - input  reset
 - input  data
 - output count (4 bits)
 - output counting
 - output done
 - input  ack

The module should implement a timer with one input that:

  (1) is started when a particular input pattern (1101) is detected,
  (2) shifts in 4 more bits to determine the duration to delay,
  (3) waits for the counters to finish counting, and
  (4) notifies the user and waits for the user to acknowledge the timer.

The serial data is available on the data input pin. When the pattern 1101
is received, the circuit must then shift in the next 4 bits,
most-significant-bit first. These 4 bits determine the duration of the
timer delay, referred to as delay[3:0]. After that, the state machine
asserts its counting output to indicate it is counting. Once the 1101 and
delay[3:0] have been read, the circuit no longer looks at the data input
until it resumes searching after everything else is done.

The state machine must count for exactly (delay[3:0] + 1) * 1000 clock
cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count
6000 cycles. Also output the current remaining time. This should be equal
to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until
it is 0 for 1000 cycles.

When the circuit isn't counting, the count[3:0] output is don't-care
(whatever value is convenient for you to implement). At that point, the
circuit must assert done to notify the user the timer has timed out, and
waits until input ack is 1 before being reset to look for the next
occurrence of the start sequence (1101).

The circuit should reset into a state where it begins searching for the
input sequence 1101. The reset signal is active high synchronous. Assume
all sequential logic is triggered on the positive edge of the clock.

Here is the enhanced specification which might be useful to you:
                **Module: TopModule**

**Interface:**
- `input clk`: Clock signal, positive edge-triggered.
- `input reset`: Active high synchronous reset.
- `input data`: Serial data input, 1 bit.
- `output reg [3:0] count`: 4-bit output representing the current remaining time in the countdown.
- `output reg counting`: 1-bit signal asserted when the timer is active.
- `output reg done`: 1-bit signal asserted when the timer has completed its countdown.
- `input ack`: Acknowledgment signal from the user, 1 bit.

**Behavior:**
1. **Startup and Reset:**
   - On a reset (`reset = 1`), the module enters a state where it searches for the pattern `1101` on the `data` input. All outputs are initialized: `count = 4'bxxxx`, `counting = 0`, `done = 0`.

2. **Pattern Detection and Delay Capture:**
   - Upon detecting the pattern `1101` on the `data` input, the module shifts in the next 4 bits (`delay[3:0]`), MSB first, to determine the delay length.
   - During this phase, `count` remains don't-care (`4'bxxxx`).

3. **Counting Phase:**
   - Once `delay[3:0]` is captured, `counting` is asserted (`counting = 1`).
   - The module then counts down for exactly `(delay[3:0] + 1) * 1000` clock cycles.
   - The `count` output is updated every 1000 clock cycles to reflect the current remaining time: starting from `delay[3:0]` and decrementing by 1 every 1000 cycles until it reaches 0.

4. **Completion and Acknowledgment:**
   - After completing the countdown, `counting` is de-asserted (`counting = 0`), and `done` is asserted (`done = 1`).
   - The module waits for `ack = 1` before resetting to search for the next occurrence of the pattern `1101`.
   - During this waiting phase, `count` remains don't-care (`4'bxxxx`).

**Timing and Implementation Notes:**
- All sequential logic is triggered on the positive edge of the `clk`.
- The module should handle edge cases for `delay[3:0]` values of `0000b` to `1111b` robustly, ensuring the countdown is correctly calculated.
- The precedence of the reset signal is such that if `reset = 1`, all operations halt, and the module resets immediately on the next clock edge.
- A formal state machine diagram should be used to design the internal control logic, ensuring clear transitions between pattern detection, delay capture, counting, and acknowledgment phases.
                