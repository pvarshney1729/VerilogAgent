
I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.

 - input  clk
 - input  areset

 - input  predict_valid,
 - input  predict_pc (7 bits)
 - output predict_taken
 - output predict_history (7 bits)

 - input  train_valid
 - input  train_taken
 - input  train_mispredicted
 - input  train_history (7 bits)
 - input  train_pc (7 bits)

The module should implement a gshare branch predictor with 7-bit pc and
7-bit global history, hashed (using xor) into a 7-bit index. This index
accesses a 128-entry table of two-bit saturating counters. The branch
predictor should contain a 7-bit global branch history register. The
branch predictor has two sets of interfaces: One for doing predictions
and one for doing training. The prediction interface is used in the
processor's Fetch stage to ask the branch predictor for branch direction
predictions for the instructions being fetched. Once these branches
proceed down the pipeline and are executed, the true outcomes of the
branches become known. The branch predictor is then trained using the
actual branch direction outcomes.

When a branch prediction is requested (predict_valid = 1) for a given pc,
the branch predictor produces the predicted branch direction and state of
the branch history register used to make the prediction. The branch
history register is then updated (at the next positive clock edge) for
the predicted branch.

When training for a branch is requested (train_valid = 1), the branch
predictor is told the pc and branch history register value for the branch
that is being trained, as well as the actual branch outcome and whether
the branch was a misprediction (needing a pipeline flush). Update the
pattern history table (PHT) to train the branch predictor to predict this
branch more accurately next time. In addition, if the branch being
trained is mispredicted, also recover the branch history register to the
state immediately after the mispredicting branch completes execution.

If training for a misprediction and a prediction (for a different,
younger instruction) occurs in the same cycle, both operations will want
to modify the branch history register. When this happens, training takes
precedence, because the branch being predicted will be discarded anyway.
If training and prediction of the same PHT entry happen at the same time,
the prediction sees the PHT state before training because training only
modifies the PHT at the next positive clock edge. The following timing
diagram shows the timing when training and predicting PHT entry 0 at the
same time. The training request at cycle 4 changes the PHT entry state in
cycle 5, but the prediction request in cycle 4 outputs the PHT state at
cycle 4, without considering the effect of the training request in cycle
4. Reset is asynchronous active-high.

Assume all sequential logic is triggered on the positive edge of the
clock.

Here is the enhanced specification which might be useful to you:
                **TopModule Specification**

**1. Interface Definition:**
- **Inputs:**
  - `input wire clk`: Clock signal, positive edge-triggered.
  - `input wire areset`: Asynchronous active-high reset signal.
  - `input wire predict_valid`: Indicates a valid prediction request (1 bit).
  - `input wire [6:0] predict_pc`: Program counter for prediction (7 bits, unsigned).
  - `input wire train_valid`: Indicates a valid training request (1 bit).
  - `input wire train_taken`: Actual branch outcome for training (1 bit).
  - `input wire train_mispredicted`: Indicates a misprediction occurred (1 bit).
  - `input wire [6:0] train_history`: Branch history for training (7 bits, unsigned).
  - `input wire [6:0] train_pc`: Program counter for training (7 bits, unsigned).

- **Outputs:**
  - `output reg predict_taken`: Predicted branch direction (1 bit).
  - `output reg [6:0] predict_history`: State of the branch history register used for prediction (7 bits, unsigned).

**2. Behavior and Timing:**
- **Gshare Branch Predictor:**
  - **Prediction:**
    - When `predict_valid` is asserted, the predictor computes a 7-bit index by XORing `predict_pc` and the current 7-bit global branch history.
    - The index is used to access a 128-entry pattern history table (PHT) of two-bit saturating counters.
    - The counter value determines the predicted branch direction: `00` or `01` for not taken (`predict_taken = 0`), `10` or `11` for taken (`predict_taken = 1`).
    - The `predict_history` output reflects the branch history register value used during prediction.

  - **Training:**
    - When `train_valid` is asserted, the predictor updates the PHT based on `train_pc`, `train_history`, and `train_taken`.
    - If `train_mispredicted` is asserted, the global history register is restored to the value immediately after the mispredicted branch.

- **Conflict Resolution:**
  - If both prediction and training requests occur in the same cycle for the same PHT entry, training takes precedence.
  - Prediction outputs the PHT state before any training updates in the same cycle.

**3. Reset and Initial States:**
- The global branch history register and all PHT counters initialize to zero upon receiving an active-high `areset`.
- PHT counters operate as two-bit saturating counters:
  - Initial state: `00`
  - Saturating increments and decrements adjust the counter without exceeding `11` or decreasing below `00`.

**4. Implementation Notes:**
- XOR operation for the index is `index = predict_pc ^ global_history`.
- Bit ordering is 0-indexed, with bit[0] as the least significant bit (LSB).
- Ensure no race conditions by handling all updates on the positive edge of the clock.

**5. Boundary Conditions:**
- Handle edge cases such as all `0`s and all `1`s in inputs consistently, ensuring no overflow or underflow in the saturating counters.
                