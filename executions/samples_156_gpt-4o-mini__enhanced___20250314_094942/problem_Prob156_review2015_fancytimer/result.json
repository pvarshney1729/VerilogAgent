{
    "code": "module TopModule (\n    input  logic clk,            // Clock signal (positive edge triggered)\n    input  logic reset,          // Active high synchronous reset\n    input  logic data,           // Serial input data\n    output logic [3:0] count,    // 4-bit output for current count value\n    output logic counting,        // Indicates counting state (active high)\n    output logic done,           // Indicates timer completion (active high)\n    input  logic ack             // Acknowledgment input from user\n);\n\n    typedef enum logic [1:0] {\n        IDLE,\n        PATTERN_DETECT,\n        SHIFT_DELAY,\n        COUNTING,\n        DONE_STATE\n    } state_t;\n\n    state_t current_state, next_state;\n    logic [3:0] delay;\n    logic [19:0] cycle_counter; // To count up to (delay + 1) * 1000\n    logic [9:0] count_cycles;    // To count 1000 cycles for decrementing count\n\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            count <= 4'b0000;\n            counting <= 1'b0;\n            done <= 1'b0;\n            cycle_counter <= 20'b0;\n            count_cycles <= 10'b0;\n            delay <= 4'b0000;\n        end else begin\n            current_state <= next_state;\n            if (current_state == COUNTING) begin\n                if (cycle_counter == 20'd999999) begin\n                    cycle_counter <= 20'b0;\n                    count_cycles <= count_cycles + 1'b1;\n                end else begin\n                    cycle_counter <= cycle_counter + 1'b1;\n                end\n            end\n            if (current_state == DONE_STATE && ack) begin\n                count <= 4'b0000;\n                counting <= 1'b0;\n                done <= 1'b0;\n            end\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        if (current_state == COUNTING) begin\n            if (count_cycles < (delay + 1'b1)) begin\n                if (count_cycles % 10'd1000 == 0) begin\n                    count <= delay - (count_cycles / 10'd1000);\n                end\n            end else begin\n                next_state <= DONE_STATE;\n            end\n        end\n    end\n\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                done = 1'b0;\n                counting = 1'b0;\n                if (data == 1'b1) begin\n                    next_state = PATTERN_DETECT;\n                end\n            end\n            PATTERN_DETECT: begin\n                if (data == 1'b1) begin\n                    next_state = SHIFT_DELAY;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            SHIFT_DELAY: begin\n                if (data == 1'b0) begin\n                    delay[3] = data;\n                    next_state = COUNTING;\n                end else begin\n                    delay = {delay[2:0], data};\n                end\n            end\n            COUNTING: begin\n                counting = 1'b1;\n                if (count_cycles >= (delay + 1'b1)) begin\n                    next_state = DONE_STATE;\n                end\n            end\n            DONE_STATE: begin\n                done = 1'b1;\n                counting = 1'b0;\n                if (ack) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "C"
    }
}