{
    "code": "module TopModule (\n    input logic clk,              // Clock input (1-bit)\n    input logic reset,            // Synchronous reset input (1-bit, active high)\n    input logic data,             // Serial data input (1-bit)\n    input logic done_counting,    // Done counting signal (1-bit)\n    input logic ack,              // Acknowledgment signal (1-bit)\n    output logic shift_ena,       // Shift enable output (1-bit)\n    output logic counting,         // Counting output (1-bit)\n    output logic done             // Done output (1-bit)\n);\n\n// State Definitions\ntypedef enum logic [1:0] {\n    IDLE = 2'b00,               // Waiting for sequence 1101\n    SHIFT = 2'b01,              // Shifting in duration\n    COUNTING = 2'b10,           // Waiting for counting to complete\n    DONE = 2'b11                // Timer has timed out\n} state_t;\n\nstate_t current_state, next_state;\n\n// Pattern detection and shifting logic\nlocalparam PATTERN = 4'b1101;  // Define the pattern to search for\nlogic [3:0] shift_reg;          // Shift register to hold incoming bits\nlogic [1:0] bit_count;          // Count of bits shifted\n\n// Initial state assignment\ninitial begin\n    current_state = IDLE;\n    shift_ena = 0;\n    counting = 0;\n    done = 0;\n    shift_reg = 4'b0000;\n    bit_count = 2'b00;\nend\n\n// State Transition and Output Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= IDLE;    // Reset state to IDLE\n        shift_ena <= 0;\n        counting <= 0;\n        done <= 0;\n        shift_reg <= 4'b0000;\n        bit_count <= 2'b00;\n    end else begin\n        current_state <= next_state; // Update current state\n    end\nend\n\n// Next State Logic and Output Control\nalways @(*) begin\n    // Default outputs\n    next_state = current_state;\n    shift_ena = 0;\n    counting = 0;\n    done = 0;\n\n    case (current_state)\n        IDLE: begin\n            // Shift in incoming data bit\n            shift_reg = {shift_reg[2:0], data};\n            if (shift_reg == PATTERN) begin\n                next_state = SHIFT;      // Move to SHIFT state upon pattern detection\n            end\n        end\n\n        SHIFT: begin\n            shift_ena = 1;              // Assert shift enable\n            bit_count = bit_count + 1;  // Increment bit count\n            if (bit_count == 2'b11) begin\n                next_state = COUNTING;  // Move to COUNTING state after 4 bits\n                bit_count = 0;          // Reset bit count\n            end\n        end\n\n        COUNTING: begin\n            counting = 1;               // Indicate counting is in progress\n            if (done_counting) begin\n                next_state = DONE;      // Move to DONE state when counting is complete\n            end\n        end\n\n        DONE: begin\n            done = 1;                   // Assert done output\n            if (ack) begin\n                next_state = IDLE;      // Wait for acknowledgment to return to IDLE\n            end\n        end\n    endcase\nend\n\nendmodule",
    "test_results": {
        "num_mismatch": 1632,
        "passfail": "R"
    }
}