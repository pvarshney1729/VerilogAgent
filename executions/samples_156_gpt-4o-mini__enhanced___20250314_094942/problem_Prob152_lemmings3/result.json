{
    "code": "module TopModule (\n    input  logic clk,          // Clock signal\n    input  logic areset,      // Asynchronous reset signal (active high)\n    input  logic bump_left,    // Input signal to indicate bump to the left (active high)\n    input  logic bump_right,   // Input signal to indicate bump to the right (active high)\n    input  logic ground,       // Input signal to indicate presence of ground (active high)\n    input  logic dig,          // Input signal to indicate digging action (active high)\n    output logic walk_left,    // Output signal for walking left (active high)\n    output logic walk_right,   // Output signal for walking right (active high)\n    output logic aaah,         // Output signal indicating the Lemming is falling (active high)\n    output logic digging        // Output signal indicating the Lemming is digging (active high)\n);\n\n// State encoding for FSM\ntypedef enum logic [1:0] {\n    STATE_WALK_LEFT,\n    STATE_WALK_RIGHT,\n    STATE_FALLING,\n    STATE_DIGGING\n} state_t;\n\nstate_t current_state, next_state;\n\n// Timing Behavior\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        current_state <= STATE_WALK_LEFT; // Reset state\n        walk_left <= 1'b1;                 // Initial output state\n        walk_right <= 1'b0;\n        aaah <= 1'b0;\n        digging <= 1'b0;\n    end else begin\n        current_state <= next_state; // Update state on clock edge\n    end\nend\n\n// Next state logic\nalways_comb begin\n    // Default outputs\n    walk_left = 1'b0;\n    walk_right = 1'b0;\n    aaah = 1'b0;\n    digging = 1'b0;\n    \n    case (current_state)\n        STATE_WALK_LEFT: begin\n            walk_left = 1'b1;\n            if (ground == 1'b0) begin\n                next_state = STATE_FALLING;\n                aaah = 1'b1; // Start falling\n            end else if (bump_right) begin\n                next_state = STATE_WALK_RIGHT;\n            end else if (dig && ground) begin\n                next_state = STATE_DIGGING;\n                digging = 1'b1; // Start digging\n            end else begin\n                next_state = STATE_WALK_LEFT; // Remain in current state\n            end\n        end\n\n        STATE_WALK_RIGHT: begin\n            walk_right = 1'b1;\n            if (ground == 1'b0) begin\n                next_state = STATE_FALLING;\n                aaah = 1'b1; // Start falling\n            end else if (bump_left) begin\n                next_state = STATE_WALK_LEFT;\n            end else if (dig && ground) begin\n                next_state = STATE_DIGGING;\n                digging = 1'b1; // Start digging\n            end else begin\n                next_state = STATE_WALK_RIGHT; // Remain in current state\n            end\n        end\n\n        STATE_FALLING: begin\n            aaah = 1'b1; // Falling state persists\n            if (ground == 1'b1) begin\n                // Resume walking in the last direction\n                next_state = (walk_left ? STATE_WALK_LEFT : STATE_WALK_RIGHT);\n            end else begin\n                next_state = STATE_FALLING; // Continue falling\n            end\n        end\n\n        STATE_DIGGING: begin\n            digging = 1'b1; // Digging state persists\n            if (ground == 1'b0) begin\n                next_state = STATE_FALLING; // Fall if no ground\n                aaah = 1'b1;\n            end else if (bump_left || bump_right) begin\n                // Bump does not affect digging\n                next_state = STATE_DIGGING;\n            end else begin\n                next_state = STATE_DIGGING; // Continue digging\n            end\n        end\n\n        default: next_state = STATE_WALK_LEFT; // Default case for safety\n    endcase\nend\n\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "e"
    }
}