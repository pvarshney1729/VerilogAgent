[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  in\n - input  reset\n - output out_byte (8 bits)\n - output done\n\nIn many (older) serial communications protocols, each data byte is sent\nalong with a start bit and a stop bit, to help the receiver delimit bytes\nfrom the stream of bits. One common scheme is to use one start bit (0), 8\ndata bits, and 1 stop bit (1). The line is also at logic 1 when nothing\nis being transmitted (idle). Design a finite state machine that will\nidentify when bytes have been correctly received when given a stream of\nbits. It needs to identify the start bit, wait for all 8 data bits, then\nverify that the stop bit was correct. The module will also output the\ncorrectly-received data byte. `out_byte` needs to be valid when `done` is\n1, and is don't-care otherwise. If the stop bit does not appear when\nexpected, the FSM must wait until it finds a stop bit before attempting\nto receive the next byte. Include a active-high synchronous reset. Note\nthat the serial protocol sends the least significant bit first. It should\nassert done each time it finds a stop bit. Assume all sequential logic is\ntriggered on the positive edge of the clock.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops to zero in simulation.\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Infer logic correctly, especially when using Karnaugh maps.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE].\n</CODE>\n"
    },
    {
        "role": "assistant",
        "content": "Here is the enhanced specification which might be useful:\n                    Module Name: TopModule\n\nPort Interface:\n- Input Ports:\n  - clk: 1-bit input (clock signal, positive edge-triggered)\n  - in: 1-bit input (serial data input)\n  - reset: 1-bit input (active-high synchronous reset)\n\n- Output Ports:\n  - out_byte: 8-bit output (data byte received, valid when done is high)\n  - done: 1-bit output (indicates that a valid byte has been received)\n\nProtocol Description:\nThis module implements a finite state machine (FSM) for a serial communication protocol that transmits data in the following format:\n- 1 start bit (logic 0)\n- 8 data bits (LSB first)\n- 1 stop bit (logic 1)\n\nBehavioral Specifications:\n1. The FSM shall identify the start bit (0) and transition to a receiving state.\n2. Upon detecting a valid start bit, the FSM shall wait for the subsequent 8 data bits, ensuring they are received in the correct order (from LSB to MSB).\n3. After receiving all 8 data bits, the FSM shall verify the presence of a stop bit (1).\n4. The `out_byte` output shall hold the received data byte when `done` is asserted (logic 1). The value of `out_byte` is considered don't-care when `done` is not asserted (logic 0).\n5. If the expected stop bit is not detected after receiving the data bits, the FSM shall remain in a waiting state until a valid stop bit is received before attempting to process the next byte.\n6. The `done` signal shall be asserted high each time a stop bit is successfully detected.\n7. The FSM is designed to operate with a synchronous reset. Upon the assertion of the reset signal, all internal state variables shall be reset to their initial states:\n   - `out_byte` shall be set to 8'b00000000.\n   - The FSM state shall transition to an idle state, ready to receive the next start bit.\n\nEdge Case Handling:\n- The module shall handle the idle state where the line is held at logic 1 (no transmission).\n- The FSM must account for noise or invalid bit patterns and shall only transition upon detecting valid start and stop conditions.\n\nTiming and Signal Dependencies:\n- All sequential logic is triggered on the positive edge of the `clk`.\n- The FSM must ensure that no race conditions occur by clearly defining the state transitions and dependencies based on input signals.\n\nBit Indexing:\n- The `out_byte` output is indexed as `out_byte[0]` (LSB) to `out_byte[7]` (MSB).\n\nAdditional Notes:\n- The design must consider proper timing margins for detecting state transitions and ensure that the sampling of the `in` signal occurs at appropriate times relative to the `clk` signal.\n                    "
    }
]