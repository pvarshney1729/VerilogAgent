[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "<Question>\nConsider the following adder-subtractor with a zero flag:\n\n  module TopModule (\n      input      cpu_overheated,\n      output reg shut_off_computer,\n      input      arrived,\n      input      gas_tank_empty,\n      output reg keep_driving\n  );\n\n      always @(*) begin\n          if (cpu_overheated)\n             shut_off_computer = 1;\n      end\n\n      always @(*) begin\n          if (~arrived)\n             keep_driving = ~gas_tank_empty;\n      end\n\n  endmodule\n\nUnfortunately, this module has a bug. Implement a new version of this\nmodule that fixes the bug.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops to zero in simulation.\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Infer logic correctly, especially when using Karnaugh maps.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE].\n</CODE>\n"
    },
    {
        "role": "assistant",
        "content": "Here is the enhanced specification which might be useful:\n                    Consider the following enhanced adder-subtractor with a zero flag:\n\n  module TopModule (\n      input      cpu_overheated,            // 1-bit input signal indicating if the CPU is overheated\n      output reg shut_off_computer,         // 1-bit output signal indicating whether to shut off the computer\n      input      arrived,                    // 1-bit input signal indicating whether the destination has been arrived at\n      input      gas_tank_empty,            // 1-bit input signal indicating if the gas tank is empty\n      output reg keep_driving                // 1-bit output signal indicating whether to keep driving\n  );\n\n      // The shut_off_computer signal is asserted (set to 1) when cpu_overheated is true\n      // This is combinational logic\n      always @(*) begin\n          shut_off_computer = 1'b0;           // Default state\n          if (cpu_overheated) begin\n              shut_off_computer = 1'b1;       // Set to 1 if CPU is overheated\n          end\n      end\n\n      // The keep_driving signal is determined based on the arrived signal and the gas_tank_empty signal\n      // If not arrived, keep_driving is set to the inverse of gas_tank_empty\n      // This is also combinational logic\n      always @(*) begin\n          keep_driving = 1'b0;                // Default state\n          if (~arrived) begin\n              keep_driving = ~gas_tank_empty; // Set to 1 if gas_tank_empty is false (not empty)\n          end\n      end\n\n  endmodule\n                    "
    }
]