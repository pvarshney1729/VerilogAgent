{
    "code": "module TopModule (\n    input  logic clk,\n    input  logic load,\n    input  logic [511:0] data,\n    output logic [511:0] q\n);\n\n    // Intermediate storage for next state\n    logic [511:0] next_q;\n\n    // Always block for updating the state on clock edge\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load new data if load signal is high\n        end else begin\n            // Compute next state based on Rule 110\n            next_q[0]   = 0;                              // q[-1] is considered as 0\n            next_q[511] = 0;                              // q[512] is considered as 0\n            \n            for (int i = 0; i < 511; i++) begin\n                next_q[i+1] = ( (q[i] == 1 && q[i+1] == 1 && (i == 0 ? 0 : q[i-1] == 1)) ? 0 :\n                                 (q[i] == 1 && (i == 0 ? 0 : q[i-1] == 0) && q[i+1] == 1) ? 1 :\n                                 (q[i] == 1 && (i == 0 ? 0 : q[i-1] == 1) && q[i+1] == 0) ? 1 :\n                                 (q[i] == 1 && (i == 0 ? 0 : q[i-1] == 0) && q[i+1] == 0) ? 0 :\n                                 (q[i] == 0 && q[i+1] == 1 && (i == 0 ? 0 : q[i-1] == 1)) ? 1 :\n                                 (q[i] == 0 && q[i+1] == 0 && (i == 0 ? 0 : q[i-1] == 0)) ? 0 :\n                                 (q[i] == 0 && q[i+1] == 1 && (i == 0 ? 0 : q[i-1] == 0)) ? 1 :\n                                 (q[i] == 0 && (i == 0 ? 0 : q[i-1] == 0) && (q[i+1] == 0)) ? 0 : 0) ) );\n            end\n            \n            // Update the state to the next state\n            q <= next_q;\n        end\n    end\n\n    // Initialize q to 0 in simulation\n    initial begin\n        q = 512'b0;  // All cells off\n    end\n\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "S"
    }
}