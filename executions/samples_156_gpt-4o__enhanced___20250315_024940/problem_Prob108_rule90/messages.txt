[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk,\n - input  load,\n - input  data (512 bits)\n - output q    (512 bits)\n\nThe module should implement Rule 90, a one-dimensional cellular automaton\nwith interesting properties. The rules are simple. There is a\none-dimensional array of cells (on or off). At each time step, the next\nstate of each cell is the XOR of the cell's two current neighbours:\n\n  Left | Center | Right | Center's next state\n  1    | 1      | 1     | 0\n  1    | 1      | 0     | 1\n  1    | 0      | 1     | 0\n  1    | 0      | 0     | 1\n  0    | 1      | 1     | 1\n  0    | 1      | 0     | 0\n  0    | 0      | 1     | 1\n  0    | 0      | 0     | 0\n\nIn this circuit, create a 512-cell system (q[511:0]), and advance by one\ntime step each clock cycle. The load input indicates the state of the\nsystem should be loaded with data[511:0]. Assume the boundaries (q[-1]\nand q[512]) are both zero (off). Assume all sequential logic is triggered\non the positive edge of the clock.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops to zero in simulation.\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Infer logic correctly, especially when using Karnaugh maps.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE].\n</CODE>\n"
    },
    {
        "role": "assistant",
        "content": "Here is the enhanced specification which might be useful:\n                    Module Name: TopModule\n\nInterface:\n- Input Ports:\n  - clk: 1-bit input representing the clock signal. \n  - load: 1-bit input for loading initial data into the system.\n  - data: 512-bit input representing the initial state of the cellular automaton (data[511:0]).\n\n- Output Ports:\n  - q: 512-bit output representing the current state of the cellular automaton (q[511:0]).\n\nSpecifications:\n1. The module implements Rule 90, a one-dimensional cellular automaton.\n2. The state of each cell in the array is determined by the XOR of its two immediate neighbors.\n3. The cell array is indexed as follows:\n   - q[0] is the least significant cell (LSB).\n   - q[511] is the most significant cell (MSB).\n   - For boundary conditions, assume q[-1] and q[512] are both zero (off) for all calculations.\n\n4. The module operates as follows:\n   - On the rising edge of clk:\n     - If load is high (1), initialize the state of the cellular automaton with data[511:0] (i.e., set q <= data).\n     - If load is low (0), compute the next state of q based on the current values of q using the following rule:\n       - For each cell q[i] (where 1 \u2264 i \u2264 510):\n         - q[i] = (q[i-1] XOR q[i+1]), with the following initial conditions:\n           - q[0] = (0 XOR q[1])\n           - q[511] = (q[510] XOR 0)\n\n5. Reset Conditions:\n   - The module does not specify a reset signal; consider implementing an asynchronous active-low reset signal if needed for initialization.\n\n6. Sequential Logic:\n   - All state updates occur on the positive edge of the clk signal.\n   - Ensure all registers (including the q register) are initialized to a defined state when loaded.\n\n7. Edge Cases:\n   - If the load signal is asserted (high) while clk is high, the data should be loaded without affecting the current state of q until the next clock cycle.\n   - Ensure proper handling of the boundaries where q[-1] and q[512] are considered zero.\n\n8. Signal Dependencies:\n   - Ensure that the computation of the next state for each cell does not introduce race conditions due to concurrent updates.\n\n9. Operational Characteristics:\n   - The module should exhibit stable behavior for all possible input combinations within the defined boundaries.\n\nEnd of Specification.\n                    "
    }
]