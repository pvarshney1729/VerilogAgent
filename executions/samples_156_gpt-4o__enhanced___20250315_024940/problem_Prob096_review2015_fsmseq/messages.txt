[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  data\n - output start_shifting\n\nThe module should implement a finite-state machine that searches for the\nsequence 1101 in an input bit stream. When the sequence is found, it\nshould set start_shifting to 1, forever, until reset. Reset is active\nhigh synchronous. Assume all sequential logic is triggered on the\npositive edge of the clock.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops to zero in simulation.\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Infer logic correctly, especially when using Karnaugh maps.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE].\n</CODE>\n"
    },
    {
        "role": "assistant",
        "content": "Here is the enhanced specification which might be useful:\n                    Module Name: TopModule\n\nInterface:\n- Input Ports:\n  - clk: 1-bit input signal representing the clock. This signal is used to trigger all sequential logic on the positive edge.\n  - reset: 1-bit input signal representing the active high synchronous reset. When asserted high, it will reset the state of the module.\n  - data: 1-bit input signal representing the incoming bit stream to be analyzed for the sequence 1101.\n\n- Output Ports:\n  - start_shifting: 1-bit output signal. When the sequence 1101 is detected in the data input stream, this signal will be set high (1) and will remain high until the reset signal is asserted.\n\nFunctional Description:\nThe TopModule implements a finite-state machine (FSM) designed to search for the specific bit sequence 1101 within the incoming data stream. \n\nState Transition and Output Behavior:\n1. On the rising edge of clk, if reset is asserted, then:\n   - All internal state variables should be reset to their initial values.\n   - start_shifting should be set to 0.\n   \n2. If reset is not asserted, the FSM will monitor the data input. \n   - Upon detecting the sequence 1101, the output signal start_shifting should transition to high (1) and remain high until the next assertion of the reset signal.\n   \n3. The FSM should account for potential edge cases, such as:\n   - The sequence being detected immediately at the start of the input stream.\n   - The sequence being split across two clock cycles.\n   - Continuous input of bits that do not form the sequence.\n\nState Definitions:\n- Define all necessary states for the FSM, including states for tracking the detection of each bit in the sequence 1101, and ensure that transitions between states are clearly specified.\n\nInitial Values:\n- All state variables must have explicitly defined initial values upon reset, ensuring predictable behavior.\n\nReset Behavior:\n- The FSM must clearly define the reset state of all registers and flip-flops, ensuring they return to a known state.\n\nSignal Dependencies:\n- Clearly outline dependencies of states on the data input and ensure that any potential race conditions are handled through proper state management.\n\nTesting and Verification:\n- Provide a truth table or state transition diagram to describe the expected behavior of the FSM for each combination of input data.\n\nEnd of Specification.\n                    "
    }
]