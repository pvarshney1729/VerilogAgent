[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  bump_left\n - input  bump_right\n - output walk_left\n - output walk_right\n\nThe module should implement a simple game called Lemmings which involves\ncritters with fairly simple brains. So simple that we are going to model\nit using a finite state machine. In the Lemmings' 2D world, Lemmings can\nbe in one of two states: walking left (walk_left is 1) or walking right\n(walk_right is 1). It will switch directions if it hits an obstacle. In\nparticular, if a Lemming is bumped on the left (by receiving a 1 on\nbump_left), it will walk right. If it's bumped on the right (by receiving\na 1 on bump_right), it will walk left. If it's bumped on both sides at\nthe same time, it will still switch directions.\n\nThe module should implement a Moore state machine with two states, two\ninputs, and one output (internal to the module) that models this\nbehaviour. areset is positive edge triggered asynchronous resetting the\nLemming machine to walk left. Assume all sequential logic is triggered on\nthe positive edge of the clock.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops to zero in simulation.\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Infer logic correctly, especially when using Karnaugh maps.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE].\n</CODE>\n"
    },
    {
        "role": "assistant",
        "content": "Here is the enhanced specification which might be useful:\n                    Module Name: TopModule\n\nInterface Definition:\n- Input Ports:\n  - input clk: 1-bit clock signal (positive edge triggered)\n  - input areset: 1-bit asynchronous reset signal (active high)\n  - input bump_left: 1-bit signal indicating a bump from the left (active high)\n  - input bump_right: 1-bit signal indicating a bump from the right (active high)\n\n- Output Ports:\n  - output reg walk_left: 1-bit output indicating Lemming is walking left (active high)\n  - output reg walk_right: 1-bit output indicating Lemming is walking right (active high)\n\nState Definitions:\n- The module implements a Moore finite state machine (FSM) with the following states:\n  - State 0: Walking Left (walk_left = 1, walk_right = 0)\n  - State 1: Walking Right (walk_left = 0, walk_right = 1)\n\nState Transition Logic:\n- The Lemming transitions between states based on the following conditions:\n  - If bump_left is asserted (1), transition to State 1 (walk_right = 1).\n  - If bump_right is asserted (1), transition to State 0 (walk_left = 1).\n  - If both bump_left and bump_right are asserted simultaneously, the Lemming will switch directions according to the last bump detected.\n\nReset Behavior:\n- The areset signal resets the state machine to State 0 (walking left) on the positive edge of the clk signal.\n- Upon reset, the output signals are defined as follows:\n  - walk_left = 1\n  - walk_right = 0\n\nSequential Logic:\n- All state transitions and output assignments occur on the positive edge of the clk signal, ensuring synchronous behavior.\n- The outputs walk_left and walk_right will only reflect the current state after the clk positive edge.\n\nEdge Case Behavior:\n- The FSM must be designed to handle simultaneous bumps (bump_left and bump_right both being high) consistently, prioritizing the last change detected before the clock edge.\n- Ensure correct initialization of the FSM and outputs to avoid undefined behavior upon startup.\n\nSignal Dependencies:\n- Ensure that the bump signals are checked immediately upon the positive edge of clk for state transitions, to avoid race conditions.\n\nInitialization:\n- All registers and outputs should have defined initial values upon reset.\n                    "
    }
]