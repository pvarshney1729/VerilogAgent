[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  ena  (  2 bits)\n - input  data (100 bits)\n - output q    (100 bits)\n\nThe module should implement a 100-bit left/right rotator, with\nsynchronous load and left/right enable. A rotator shifts-in the\nshifted-out bit from the other end of the register, unlike a shifter that\ndiscards the shifted-out bit and shifts in a zero. If enabled, a rotator\nrotates the bits around and does not modify/discard them.\n\n  (1) load: Loads shift register with data[99:0] instead of rotating.\n      Synchronous active high.\n\n  (2) ena[1:0]: Synchronous. Chooses whether and which direction to\n      rotate:\n      (a) 2'b01 rotates right by one bit,\n      (b) 2'b10 rotates left by one bit,\n      (c) 2'b00 and 2'b11 do not rotate.\n\n  (3) q: The contents of the rotator.\n\n"
    },
    {
        "role": "assistant",
        "content": "To implement your requested module, I have rewritten the specification to be more clear and concise. Here is the enhanced specification:\n                    The module to be implemented is named `TopModule` and has the following interface specifications:\n\n- Inputs:\n  - `clk`: 1-bit clock input, used for synchronizing operations.\n  - `load`: 1-bit synchronous active-high input, used to load data into the register.\n  - `ena`: 2-bit synchronous input, used to control the direction and enablement of rotation.\n  - `data`: 100-bit input vector, used to load data into the shift register.\n\n- Outputs:\n  - `q`: 100-bit output vector, representing the current state of the shift register.\n\nBehavior and Functional Description:\n\n1. **Clock and Synchronization**: \n   - All operations are synchronized with the rising edge of the `clk` signal.\n\n2. **Load Operation**:\n   - When `load` is asserted high ('1') during a clock cycle, the shift register is loaded with the `data` input (`data[99:0]`). This operation has priority over rotation and occurs synchronously with the clock.\n\n3. **Enable and Rotate Operations**:\n   - The `ena` signal determines the rotation behavior if `load` is not asserted.\n   - `ena[1:0]` values:\n     - `2'b01`: Rotate right by one bit position. Bit `q[0]` receives `q[99]`.\n     - `2'b10`: Rotate left by one bit position. Bit `q[99]` receives `q[0]`.\n     - `2'b00` or `2'b11`: No rotation occurs; the output `q` remains unchanged.\n\n4. **Initial State**:\n   - The initial state of `q` after reset is undefined unless specified by an external reset logic.\n\n5. **Bit Indexing**:\n   - The vector `q[99:0]` follows a most significant bit (MSB) to least significant bit (LSB) indexing, where `q[99]` is the MSB and `q[0]` is the LSB.\n\n6. **Reset**:\n   - Ensure that the implementation includes a clear reset mechanism, either synchronous or asynchronous, to establish a known starting state if required by the system.\n\nThis specification defines a 100-bit rotator with controlled rotation and loading capabilities, ensuring a clear understanding of input handling and data flow.\n                    "
    },
    {
        "role": "user",
        "content": "Can you now decompose the specification into independent submodules, which might be useful in generating the final code?"
    },
    {
        "role": "assistant",
        "content": "To implement your requested module, I have decomposed it into the following subtasks and come up with an approach for each:\n                    SUBTASK 1: Define the module TopModule with input ports clk, load, ena[1:0], data[99:0] and output port q[99:0].\nIMPLEMENTATION:\nmodule TopModule (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]}; // Rotate right\n            2'b10: q <= {q[98:0], q[99]}; // Rotate left\n            default: q <= q; // No rotation\n        endcase\n    end\nend\n\nendmodule\n\nSUBTASK 2: Implement the synchronous load functionality to load data[99:0] into the shift register when load is high.\nIMPLEMENTATION:\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\nend\n\nSUBTASK 3: Implement the logic to rotate the shift register right by one bit when ena is 2'b01.\nIMPLEMENTATION:\nalways @(posedge clk) begin\n    if (ena == 2'b01) begin\n        q <= {q[0], q[99:1]};\n    end\nend\n\nSUBTASK 4: Implement the logic to rotate the shift register left by one bit when ena is 2'b10.\nIMPLEMENTATION:\nalways @(posedge clk) begin\n    if (ena == 2'b10) begin\n        q <= {q[98:0], q[99]};\n    end\nend\n\nSUBTASK 5: Ensure that no rotation occurs when ena is 2'b00 or 2'b11, maintaining the current state of the shift register.\nIMPLEMENTATION:\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]}; // Rotate right\n            2'b10: q <= {q[98:0], q[99]}; // Rotate left\n            2'b00, 2'b11: q <= q; // No rotation\n        endcase\n    end\nend\n\nSUBTASK 6: Assign the current state of the shift register to the output q[99:0].\nIMPLEMENTATION:\nassign q = shift_register;\n                    "
    },
    {
        "role": "user",
        "content": "Now using ALL the research you have done so far, please implement the Verilog module for the original specification:\n<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  ena  (  2 bits)\n - input  data (100 bits)\n - output q    (100 bits)\n\nThe module should implement a 100-bit left/right rotator, with\nsynchronous load and left/right enable. A rotator shifts-in the\nshifted-out bit from the other end of the register, unlike a shifter that\ndiscards the shifted-out bit and shifts in a zero. If enabled, a rotator\nrotates the bits around and does not modify/discard them.\n\n  (1) load: Loads shift register with data[99:0] instead of rotating.\n      Synchronous active high.\n\n  (2) ena[1:0]: Synchronous. Chooses whether and which direction to\n      rotate:\n      (a) 2'b01 rotates right by one bit,\n      (b) 2'b10 rotates left by one bit,\n      (c) 2'b00 and 2'b11 do not rotate.\n\n  (3) q: The contents of the rotator.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n"
    },
    {
        "role": "assistant",
        "content": "module TopModule(\n    input logic clk,\n    input logic load,\n    input logic [1:0] ena,\n    input logic [99:0] data,\n    output logic [99:0] q\n);\n\n    always_ff @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation\n            endcase\n        end\n    end\n\nendmodule"
    },
    {
        "role": "user",
        "content": "\n            The Verilog/SystemVerilog code you generated has the following issues:\n\n            <ISSUES>\n            Testbench error: Error running simulation: Command '['vvp', 'sim.out']' timed out after 5 seconds\n            </ISSUES>\n\n            This is the compiler output using your latest code:\n            \n            <COMPILER_OUTPUT>\n            Compilation ran successfully.\n            </COMPILER_OUTPUT>\n            This is the synthetic testbench output using your latest code:\n            <TESTBENCH_OUTPUT>\n            \n            </TESTBENCH_OUTPUT>\n\n            Recall that the original specification was:\n            <ORIGINAL_SPEC>\n            \nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  ena  (  2 bits)\n - input  data (100 bits)\n - output q    (100 bits)\n\nThe module should implement a 100-bit left/right rotator, with\nsynchronous load and left/right enable. A rotator shifts-in the\nshifted-out bit from the other end of the register, unlike a shifter that\ndiscards the shifted-out bit and shifts in a zero. If enabled, a rotator\nrotates the bits around and does not modify/discard them.\n\n  (1) load: Loads shift register with data[99:0] instead of rotating.\n      Synchronous active high.\n\n  (2) ena[1:0]: Synchronous. Chooses whether and which direction to\n      rotate:\n      (a) 2'b01 rotates right by one bit,\n      (b) 2'b10 rotates left by one bit,\n      (c) 2'b00 and 2'b11 do not rotate.\n\n  (3) q: The contents of the rotator.\n\n\n            </ORIGINAL_SPEC>\n\n            Please provide an improved version of the code that addresses these issues and correctly implements the specification!\n            \n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n \n            "
    },
    {
        "role": "assistant",
        "content": "<REASONING>\nTo implement the `TopModule`, we need to create a 100-bit rotator with synchronous load and rotation capabilities. The module has a clock input `clk`, a load signal `load`, a 2-bit enable signal `ena`, a 100-bit data input `data`, and a 100-bit output `q`.\n\n1. **Synchronous Load**: When `load` is high, the module should load the `data` into the output `q`. This is done synchronously with the clock, so it is placed inside an `always_ff` block triggered by the rising edge of `clk`.\n\n2. **Rotation Logic**: If `load` is not asserted, the module checks the `ena` signal to determine the rotation direction:\n   - `ena == 2'b01`: Rotate right by one bit. This is achieved by shifting `q` right and wrapping the LSB to the MSB.\n   - `ena == 2'b10`: Rotate left by one bit. This is achieved by shifting `q` left and wrapping the MSB to the LSB.\n   - `ena == 2'b00` or `ena == 2'b11`: No rotation occurs, and `q` remains unchanged.\n\n3. **Use of `always_ff`**: The `always_ff` block is used for sequential logic, ensuring that the operations are synchronized with the clock.\n\n4. **Logic Declarations**: All ports and internal signals are declared as `logic` to adhere to modern SystemVerilog conventions.\n\n5. **No Explicit Sensitivity List**: The `always_ff` block does not require an explicit sensitivity list as it is inherently sensitive to the clock edge.\n\nBy following these steps, we ensure that the module behaves as specified, with correct handling of synchronous loading and rotation operations.\n</REASONING>\n\n<CODE>\n[BEGIN]\nmodule TopModule(\n    input logic clk,\n    input logic load,\n    input logic [1:0] ena,\n    input logic [99:0] data,\n    output logic [99:0] q\n);\n\n    always_ff @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation\n            endcase\n        end\n    end\n\nendmodule\n[DONE]\n</CODE>"
    },
    {
        "role": "user",
        "content": "\n            The Verilog/SystemVerilog code you generated has the following issues:\n\n            <ISSUES>\n            Testbench error: Error running simulation: Command '['vvp', 'sim.out']' timed out after 5 seconds\n            </ISSUES>\n\n            This is the compiler output using your latest code:\n            \n            <COMPILER_OUTPUT>\n            Compilation ran successfully.\n            </COMPILER_OUTPUT>\n            This is the synthetic testbench output using your latest code:\n            <TESTBENCH_OUTPUT>\n            \n            </TESTBENCH_OUTPUT>\n\n            Recall that the original specification was:\n            <ORIGINAL_SPEC>\n            \nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  ena  (  2 bits)\n - input  data (100 bits)\n - output q    (100 bits)\n\nThe module should implement a 100-bit left/right rotator, with\nsynchronous load and left/right enable. A rotator shifts-in the\nshifted-out bit from the other end of the register, unlike a shifter that\ndiscards the shifted-out bit and shifts in a zero. If enabled, a rotator\nrotates the bits around and does not modify/discard them.\n\n  (1) load: Loads shift register with data[99:0] instead of rotating.\n      Synchronous active high.\n\n  (2) ena[1:0]: Synchronous. Chooses whether and which direction to\n      rotate:\n      (a) 2'b01 rotates right by one bit,\n      (b) 2'b10 rotates left by one bit,\n      (c) 2'b00 and 2'b11 do not rotate.\n\n  (3) q: The contents of the rotator.\n\n\n            </ORIGINAL_SPEC>\n\n            Please provide an improved version of the code that addresses these issues and correctly implements the specification!\n            \n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n \n            "
    },
    {
        "role": "assistant",
        "content": "<REASONING>\nTo implement the `TopModule`, we need to create a 100-bit rotator with synchronous load and enable controls. The module should load data into the register when `load` is high, and rotate the bits based on the `ena` input when `load` is low. The rotation should be either left or right, depending on the value of `ena`. The module uses a synchronous design, meaning all operations are triggered on the rising edge of the clock signal `clk`.\n\n1. **Module Declaration**: We declare the module `TopModule` with the specified inputs and outputs. All ports are declared as `logic` to adhere to the coding conventions.\n\n2. **Synchronous Logic**: We use an `always_ff` block triggered by the rising edge of `clk` to implement synchronous behavior. This block handles both loading and rotating operations.\n\n3. **Load Operation**: If `load` is high, the register `q` is loaded with the input `data`. This operation takes precedence over rotation.\n\n4. **Rotation Logic**: If `load` is not asserted, the `ena` signal determines the rotation behavior:\n   - `2'b01`: Rotate right by one bit. The least significant bit (LSB) `q[0]` is filled with the most significant bit (MSB) `q[99]`.\n   - `2'b10`: Rotate left by one bit. The MSB `q[99]` is filled with the LSB `q[0]`.\n   - `2'b00` and `2'b11`: No rotation occurs; the register `q` remains unchanged.\n\n5. **Output Assignment**: The output `q` directly reflects the current state of the register after each clock cycle.\n\nThis design ensures that the module meets the specified requirements for loading and rotating the 100-bit register.\n</REASONING>\n\n<CODE>\n[BEGIN]\nmodule TopModule(\n    input logic clk,\n    input logic load,\n    input logic [1:0] ena,\n    input logic [99:0] data,\n    output logic [99:0] q\n);\n\n    always_ff @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation\n            endcase\n        end\n    end\n\nendmodule\n[DONE]\n</CODE>"
    },
    {
        "role": "user",
        "content": "\n            The Verilog/SystemVerilog code you generated has the following issues:\n\n            <ISSUES>\n            Testbench error: Error running simulation: Command '['vvp', 'sim.out']' timed out after 5 seconds\n            </ISSUES>\n\n            This is the compiler output using your latest code:\n            \n            <COMPILER_OUTPUT>\n            Compilation ran successfully.\n            </COMPILER_OUTPUT>\n            This is the synthetic testbench output using your latest code:\n            <TESTBENCH_OUTPUT>\n            \n            </TESTBENCH_OUTPUT>\n\n            Recall that the original specification was:\n            <ORIGINAL_SPEC>\n            \nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  ena  (  2 bits)\n - input  data (100 bits)\n - output q    (100 bits)\n\nThe module should implement a 100-bit left/right rotator, with\nsynchronous load and left/right enable. A rotator shifts-in the\nshifted-out bit from the other end of the register, unlike a shifter that\ndiscards the shifted-out bit and shifts in a zero. If enabled, a rotator\nrotates the bits around and does not modify/discard them.\n\n  (1) load: Loads shift register with data[99:0] instead of rotating.\n      Synchronous active high.\n\n  (2) ena[1:0]: Synchronous. Chooses whether and which direction to\n      rotate:\n      (a) 2'b01 rotates right by one bit,\n      (b) 2'b10 rotates left by one bit,\n      (c) 2'b00 and 2'b11 do not rotate.\n\n  (3) q: The contents of the rotator.\n\n\n            </ORIGINAL_SPEC>\n\n            Please provide an improved version of the code that addresses these issues and correctly implements the specification!\n            \n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n \n            "
    },
    {
        "role": "assistant",
        "content": "<REASONING>\nTo implement the `TopModule`, we need to create a 100-bit rotator with specific functionalities based on the input signals. The module has a clock input `clk`, a load signal `load`, a 2-bit enable signal `ena`, a 100-bit data input `data`, and a 100-bit output `q`. The behavior of the module is as follows:\n\n1. **Load Operation**: When the `load` signal is high, the module should load the `data` input into the output `q`. This operation is synchronous with the clock.\n\n2. **Rotation Operation**: If the `load` signal is not asserted, the module should perform a rotation based on the `ena` signal:\n   - `ena = 2'b01`: Rotate the bits in `q` to the right by one position. The bit shifted out from the right end should be shifted back into the left end.\n   - `ena = 2'b10`: Rotate the bits in `q` to the left by one position. The bit shifted out from the left end should be shifted back into the right end.\n   - `ena = 2'b00` or `ena = 2'b11`: No rotation should occur, and the output `q` should remain unchanged.\n\n3. **Implementation Details**:\n   - The module uses an `always_ff` block triggered on the rising edge of the clock to ensure synchronous operation.\n   - The `case` statement is used to handle the different values of `ena` and apply the appropriate rotation or maintain the current state.\n   - The `logic` data type is used for all signals to adhere to modern Verilog conventions.\n\nBy following these steps, we ensure that the module behaves as specified, with correct handling of loading and rotating operations.\n</REASONING>\n\n<CODE>\n[BEGIN]\nmodule TopModule(\n    input logic clk,\n    input logic load,\n    input logic [1:0] ena,\n    input logic [99:0] data,\n    output logic [99:0] q\n);\n\n    always_ff @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]}; // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q; // No rotation\n            endcase\n        end\n    end\n\nendmodule\n[DONE]\n</CODE>"
    }
]