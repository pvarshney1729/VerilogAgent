[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  L\n - input  q_in\n - input  r_in\n - output Q\n\nConsider this Verilog module \"full_module\":\n\n  module full_module (\n      input [2:0] r,\n      input L,\n      input clk,\n      output reg [2:0] q);\n\n    always @(posedge clk) begin\n      if (L) begin\n        q <= r;\n      end else begin\n        q <= {q[1] ^ q[2], q[0], q[2]};\n      end\n    end\n\n  endmodule\n\nNote that q[2:0] is three bits wide, representing three flip-flops that can be\nloaded from r when L is asserted. You want to factor full_module into a hierarchical\ndesign, flipflop and 2:1 multiplexer are in a submodule \"TopModule\", and that submodule\nwill be instantiated three times in full_module code. Create the submodule called \"TopModule\".\nYou do not have to provide the revised full_module.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops to zero in simulation.\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Infer logic correctly, especially when using Karnaugh maps.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n"
    },
    {
        "role": "assistant",
        "content": "To implement your requested module, I have rewritten the specification to be more clear and concise. Here is the enhanced specification:\n                    Specification for Verilog Module: TopModule\n\nModule Name: TopModule\n\nInterface:\n- Inputs:\n  - `input wire clk`: Clock signal, used for triggering sequential logic operations on the rising edge.\n  - `input wire L`: Load signal, used to control the loading behavior.\n  - `input wire q_in`: A single-bit input to the multiplexer.\n  - `input wire r_in`: A single-bit input to the multiplexer.\n\n- Outputs:\n  - `output wire Q`: A single-bit output representing the final state of the flip-flop.\n\nDescription:\n- The `TopModule` is designed to encapsulate a 2:1 multiplexer and a D-type flip-flop.\n- The multiplexer selects between `q_in` and `r_in` based on the `L` signal.\n  - When `L` is high (`1`), the output `Q` should be set to `r_in`.\n  - When `L` is low (`0`), the output `Q` should be set to `q_in`.\n- The selected input is then stored in a D-type flip-flop which captures the input on the rising edge of `clk`.\n- The flip-flop does not have an explicit reset condition in this specification, implying it retains its state across resets unless otherwise handled externally.\n- The operation of `TopModule` is purely sequential, with all state updates occurring on the rising edge of the `clk`.\n\nNotes on Implementation:\n- Ensure that the multiplexer logic is combinational, directly reflecting changes in `L`, `q_in`, and `r_in` to its output prior to clocking.\n- The flip-flop should capture the multiplexer output on each rising edge of `clk`, updating the output `Q` accordingly.\n\nEdge Case Handling:\n- As there is no reset, initial conditions are not defined in this specification. It is assumed the initial state of `Q` is determined externally or by default simulation conditions.\n- The behavior of the flip-flop when `clk` has a non-ideal transition (such as glitches) is not specified here and should be handled by proper clock conditioning in the broader design.\n\nThis specification does not include the implementation of the `full_module`, which will instantiate the `TopModule` three times to manage three separate bits of data.\n                    "
    },
    {
        "role": "user",
        "content": "Okay, now please implement the module, ensuring syntactical and functional correctness."
    }
]