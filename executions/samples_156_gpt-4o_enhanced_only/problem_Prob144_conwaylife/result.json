{
    "code": "module TopModule(\n    input logic clk,\n    input logic load,\n    input logic [255:0] data,\n    output logic [255:0] q\n);\n\n    // Internal register to hold the current state of the grid\n    logic [255:0] next_q;\n\n    // Function to calculate the number of alive neighbors for a given cell\n    function automatic logic [3:0] count_neighbors(\n        input logic [15:0] row [0:15],\n        input int r, c\n    );\n        count_neighbors = row[(r + 15) % 16][(c + 15) % 16] + row[(r + 15) % 16][c] + row[(r + 15) % 16][(c + 1) % 16] +\n                          row[r][(c + 15) % 16] + /* Skip the center cell itself */ row[r][(c + 1) % 16] +\n                          row[(r + 1) % 16][(c + 15) % 16] + row[(r + 1) % 16][c] + row[(r + 1) % 16][(c + 1) % 16];\n    endfunction\n\n    // Sequential logic to update the grid state\n    always_ff @(posedge clk) begin\n        if (load) begin\n            // Load the initial state from data\n            q <= data;\n        end else begin\n            // Calculate the next state of the grid\n            logic [15:0] grid [0:15];\n            for (int i = 0; i < 16; i++) begin\n                grid[i] = q[(i + 1) * 16 - 1:i * 16];\n            end\n\n            for (int r = 0; r < 16; r++) begin\n                for (int c = 0; c < 16; c++) begin\n                    int count = count_neighbors(grid, r, c);\n                    logic current_state = grid[r][c];\n                    logic next_state;\n                    case (count)\n                        2: next_state = current_state; // State does not change\n                        3: next_state = 1; // Becomes alive\n                        default: next_state = 0; // Becomes dead\n                    endcase\n                    next_q[r * 16 + c] = next_state;\n                end\n            end\n            q <= next_q;\n        end\n    end\n\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "C"
    }
}