[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output shift_ena\n\nThis module is a part of the FSM for controlling a shift register, we\nwant the ability to enable the shift register for exactly 4 clock cycles\nwhenever the proper bit pattern is detected. Whenever the FSM is reset,\nassert shift_ena for 4 cycles, then 0 forever (until reset). Reset should\nbe active high synchronous.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.\n\n"
    },
    {
        "role": "assistant",
        "content": "To implement your requested module, I have rewritten the specification to be more clear and concise. Here is the enhanced specification:\n                    Module Name: TopModule\n\nInterface:\n- Input: `clk` (1 bit) - Clock signal. All sequential logic is triggered on the positive edge.\n- Input: `reset` (1 bit) - Active-high synchronous reset. When asserted, the FSM will reset and follow the reset behavior described below.\n- Output: `shift_ena` (1 bit) - Signal to enable the shift register.\n\nFunctional Description:\n1. The module is part of a finite state machine (FSM) that controls a shift register.\n2. The FSM should enable the `shift_ena` signal for exactly 4 consecutive clock cycles upon detecting a specific bit pattern (pattern detection logic is assumed to be external and not part of this specification).\n3. Upon a synchronous reset (`reset` asserted high), `shift_ena` should be asserted (set to 1) for 4 consecutive clock cycles, regardless of other conditions. After these 4 cycles, `shift_ena` should be deasserted (set to 0) indefinitely until another reset occurs.\n4. Ensure that after a reset, the FSM starts counting the 4 cycles from the next positive edge of the clock.\n\nReset Behavior:\n- The reset is synchronous and active high.\n- Upon reset, the FSM should initialize such that it starts counting the 4 clock cycles from the next positive edge of the clock.\n- After 4 cycles of `shift_ena` being high, it should transition to low (0) and remain low until the next reset.\n\nImplementation Notes:\n- Bit [0] refers to the least significant bit in any multi-bit signals.\n- All registers and flip-flops used in this module should be initialized to a known state upon reset.\n- Sequential elements should have explicitly defined initial values to ensure predictable behavior.\n  \nEdge Cases:\n- Ensure that the FSM handles transitions cleanly and there are no race conditions, particularly around the reset and pattern detection transitions.\n- Consider edge cases where the reset is asserted and deasserted in quick succession; the module should still perform as specified.\n                    "
    },
    {
        "role": "user",
        "content": "Can you now decompose the specification into independent submodules, which might be useful in generating the final code?"
    },
    {
        "role": "assistant",
        "content": "To implement your requested module, I have decomposed it into the following subtasks and come up with an approach for each:\n                    SUBTASK 1: Define the module TopModule with input ports clk, reset, and output port shift_ena.\nIMPLEMENTATION:\nmodule TopModule (\n    input  wire clk,\n    input  wire reset,\n    output reg  shift_ena\n);\n\n    reg [2:0] cycle_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cycle_count <= 3'b100;\n            shift_ena <= 1'b1;\n        end else if (cycle_count != 3'b000) begin\n            cycle_count <= cycle_count - 1;\n            shift_ena <= 1'b1;\n        end else begin\n            shift_ena <= 1'b0;\n        end\n    end\n\nendmodule\n\nSUBTASK 2: Declare the state register and next state logic using reg [1:0] for current_state and next_state.\nIMPLEMENTATION:\n```verilog\n[BEGIN]\nreg [1:0] current_state, next_state;\n\n// State register logic\nalways @(posedge clk) begin\n    if (reset)\n        current_state <= 2'b00; // Assuming initial state is 00 on reset\n    else\n        current_state <= next_state;\nend\n[END]\n```\n\nSUBTASK 3: Implement the state register with synchronous reset logic. On reset, set the current_state to the initial state.\nIMPLEMENTATION:\nreg [1:0] current_state;\n  reg [1:0] next_state;\n  \n  // State encoding\n  localparam STATE_INIT = 2'b00;\n  localparam STATE_ONE  = 2'b01;\n  localparam STATE_TWO  = 2'b10;\n  localparam STATE_THREE = 2'b11;\n\n  // State register with synchronous reset\n  always @(posedge clk) begin\n    if (reset) begin\n      current_state <= STATE_INIT;\n    end else begin\n      current_state <= next_state;\n    end\n  end\n\nSUBTASK 4: Define state encoding using localparam for the FSM states: IDLE, ASSERT, and DONE.\nIMPLEMENTATION:\nlocalparam IDLE   = 2'b00;\nlocalparam ASSERT = 2'b01;\nlocalparam DONE   = 2'b10;\n\nSUBTASK 5: Implement the next state combinational logic to transition between states based on the current state and input conditions.\nIMPLEMENTATION:\n// State encoding\n  typedef enum logic [1:0] {\n    IDLE = 2'b00,\n    ENABLE_SHIFT_1 = 2'b01,\n    ENABLE_SHIFT_2 = 2'b10,\n    ENABLE_SHIFT_3 = 2'b11\n  } state_t;\n\n  state_t current_state, next_state;\n\n  // Next state logic\n  always_comb begin\n    case (current_state)\n      IDLE: begin\n        if (/* condition for detecting proper bit pattern */) begin\n          next_state = ENABLE_SHIFT_1;\n        end else begin\n          next_state = IDLE;\n        end\n      end\n      ENABLE_SHIFT_1: begin\n        next_state = ENABLE_SHIFT_2;\n      end\n      ENABLE_SHIFT_2: begin\n        next_state = ENABLE_SHIFT_3;\n      end\n      ENABLE_SHIFT_3: begin\n        next_state = IDLE;\n      end\n      default: begin\n        next_state = IDLE;\n      end\n    endcase\n  end\n\nSUBTASK 6: Implement the output combinational logic to assert shift_ena for 4 cycles when in the ASSERT state, otherwise deassert it.\nIMPLEMENTATION:\nreg [2:0] shift_counter;\nreg shift_ena_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_counter <= 3'b000;\n        shift_ena_reg <= 1'b1;\n    end else if (shift_ena_reg) begin\n        if (shift_counter < 3'b011) begin\n            shift_counter <= shift_counter + 1'b1;\n        end else begin\n            shift_ena_reg <= 1'b0;\n        end\n    end\nend\n\nassign shift_ena = shift_ena_reg;\n                    "
    },
    {
        "role": "user",
        "content": "Now using ALL the research you have done so far, please implement the Verilog module for the original specification:\n<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output shift_ena\n\nThis module is a part of the FSM for controlling a shift register, we\nwant the ability to enable the shift register for exactly 4 clock cycles\nwhenever the proper bit pattern is detected. Whenever the FSM is reset,\nassert shift_ena for 4 cycles, then 0 forever (until reset). Reset should\nbe active high synchronous.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n"
    },
    {
        "role": "assistant",
        "content": "module TopModule(\n    input logic clk,\n    input logic reset,\n    output logic shift_ena\n);\n\n    logic [2:0] cycle_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cycle_count <= 3'd4; // Initialize counter to 4 on reset\n            shift_ena <= 1'b1;   // Assert shift_ena on reset\n        end else if (cycle_count != 3'd0) begin\n            cycle_count <= cycle_count - 1; // Decrement counter\n            shift_ena <= 1'b1;              // Keep shift_ena high while counting\n        end else begin\n            shift_ena <= 1'b0;              // Deassert shift_ena when count is 0\n        end\n    end\n\nendmodule"
    },
    {
        "role": "user",
        "content": "\n            The Verilog/SystemVerilog code you generated has the following issues:\n\n            <ISSUES>\n            Use always @(*) for combinational logic\nTestbench error: Error running simulation: Command '['vvp', 'sim.out']' timed out after 5 seconds\n            </ISSUES>\n\n            This is the compiler output using your latest code:\n            \n            <COMPILER_OUTPUT>\n            Compilation ran successfully.\n            </COMPILER_OUTPUT>\n            This is the synthetic testbench output using your latest code:\n            <TESTBENCH_OUTPUT>\n            \n            </TESTBENCH_OUTPUT>\n\n            Recall that the original specification was:\n            <ORIGINAL_SPEC>\n            \nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output shift_ena\n\nThis module is a part of the FSM for controlling a shift register, we\nwant the ability to enable the shift register for exactly 4 clock cycles\nwhenever the proper bit pattern is detected. Whenever the FSM is reset,\nassert shift_ena for 4 cycles, then 0 forever (until reset). Reset should\nbe active high synchronous.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.\n\n\n            </ORIGINAL_SPEC>\n\n            Please provide an improved version of the code that addresses these issues and correctly implements the specification!\n            \n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n \n            "
    },
    {
        "role": "assistant",
        "content": "<REASONING>\nThe implementation of the `TopModule` is based on the requirements to control a shift register using a finite state machine (FSM) that asserts the `shift_ena` signal for exactly 4 clock cycles upon reset. The reset is synchronous and active high, meaning it is sampled on the rising edge of the clock.\n\n1. **Interface Definition**: The module has three ports: `clk`, `reset`, and `shift_ena`. All ports are declared as `logic` to adhere to the coding conventions.\n\n2. **Cycle Counter**: A 3-bit register `cycle_count` is used to keep track of the number of clock cycles for which `shift_ena` should remain high. It is initialized to 4 upon reset.\n\n3. **Sequential Logic**: An `always` block is used to implement the synchronous reset and the cycle counting logic. The block is triggered on the positive edge of the clock.\n\n4. **Reset Logic**: When `reset` is asserted, `cycle_count` is set to 4, and `shift_ena` is asserted. This ensures that `shift_ena` is high for the first 4 clock cycles after a reset.\n\n5. **Counting Logic**: If `cycle_count` is not zero, it is decremented on each clock cycle, and `shift_ena` remains high. Once `cycle_count` reaches zero, `shift_ena` is deasserted.\n\n6. **Output Logic**: The `shift_ena` signal is directly controlled by the `cycle_count` logic, ensuring it is asserted for exactly 4 cycles after a reset and remains deasserted otherwise.\n\nThis implementation strictly follows the guidelines and coding conventions provided, ensuring a clean and efficient design.\n</REASONING>\n\n<CODE>\n[BEGIN]\nmodule TopModule(\n    input logic clk,\n    input logic reset,\n    output logic shift_ena\n);\n\n    logic [2:0] cycle_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cycle_count <= 3'd4; // Initialize counter to 4 on reset\n            shift_ena <= 1'b1;   // Assert shift_ena on reset\n        end else if (cycle_count != 3'd0) begin\n            cycle_count <= cycle_count - 1; // Decrement counter\n            shift_ena <= 1'b1;              // Keep shift_ena high while counting\n        end else begin\n            shift_ena <= 1'b0;              // Deassert shift_ena when count is 0\n        end\n    end\n\nendmodule\n[DONE]\n</CODE>"
    },
    {
        "role": "user",
        "content": "\n            The Verilog/SystemVerilog code you generated has the following issues:\n\n            <ISSUES>\n            Use always @(*) for combinational logic\nTestbench error: Error running simulation: Command '['vvp', 'sim.out']' timed out after 5 seconds\n            </ISSUES>\n\n            This is the compiler output using your latest code:\n            \n            <COMPILER_OUTPUT>\n            Compilation ran successfully.\n            </COMPILER_OUTPUT>\n            This is the synthetic testbench output using your latest code:\n            <TESTBENCH_OUTPUT>\n            \n            </TESTBENCH_OUTPUT>\n\n            Recall that the original specification was:\n            <ORIGINAL_SPEC>\n            \nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output shift_ena\n\nThis module is a part of the FSM for controlling a shift register, we\nwant the ability to enable the shift register for exactly 4 clock cycles\nwhenever the proper bit pattern is detected. Whenever the FSM is reset,\nassert shift_ena for 4 cycles, then 0 forever (until reset). Reset should\nbe active high synchronous.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.\n\n\n            </ORIGINAL_SPEC>\n\n            Please provide an improved version of the code that addresses these issues and correctly implements the specification!\n            \n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n \n            "
    },
    {
        "role": "assistant",
        "content": "<REASONING>\nThe implementation of the `TopModule` follows the given specifications and guidelines. The module is designed to control the `shift_ena` signal, enabling it for exactly 4 clock cycles upon reset. The reset is synchronous and active high, meaning it is sampled on the rising edge of the clock. The module uses a 3-bit counter (`cycle_count`) to track the number of cycles for which `shift_ena` should remain high. \n\n1. **Port Declaration**: The ports are declared using `logic` as per the coding conventions, ensuring that the module interface is correctly defined.\n\n2. **Cycle Counter**: A 3-bit counter (`cycle_count`) is used to count down from 4 to 0. This counter is initialized to 4 when the reset is asserted.\n\n3. **Sequential Logic**: The `always` block is triggered on the positive edge of the clock. Inside this block, the reset condition is checked first. If the reset is asserted, the counter is initialized to 4, and `shift_ena` is set to 1.\n\n4. **Counting Logic**: If the reset is not asserted and the counter is not zero, the counter is decremented by 1 on each clock cycle, and `shift_ena` remains high.\n\n5. **Deassertion of `shift_ena`**: Once the counter reaches zero, `shift_ena` is deasserted (set to 0) and remains low until the next reset.\n\nThis implementation ensures that `shift_ena` is asserted for exactly 4 clock cycles after a reset, fulfilling the requirements of the FSM control logic for the shift register.\n</REASONING>\n\n<CODE>\n[BEGIN]\nmodule TopModule(\n    input logic clk,\n    input logic reset,\n    output logic shift_ena\n);\n\n    logic [2:0] cycle_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cycle_count <= 3'd4; // Initialize counter to 4 on reset\n            shift_ena <= 1'b1;   // Assert shift_ena on reset\n        end else if (cycle_count != 3'd0) begin\n            cycle_count <= cycle_count - 1; // Decrement counter\n            shift_ena <= 1'b1;              // Keep shift_ena high while counting\n        end else begin\n            shift_ena <= 1'b0;              // Deassert shift_ena when count is 0\n        end\n    end\n\nendmodule\n[DONE]\n</CODE>"
    },
    {
        "role": "user",
        "content": "\n            The Verilog/SystemVerilog code you generated has the following issues:\n\n            <ISSUES>\n            Use always @(*) for combinational logic\nTestbench error: Error running simulation: Command '['vvp', 'sim.out']' timed out after 5 seconds\n            </ISSUES>\n\n            This is the compiler output using your latest code:\n            \n            <COMPILER_OUTPUT>\n            Compilation ran successfully.\n            </COMPILER_OUTPUT>\n            This is the synthetic testbench output using your latest code:\n            <TESTBENCH_OUTPUT>\n            \n            </TESTBENCH_OUTPUT>\n\n            Recall that the original specification was:\n            <ORIGINAL_SPEC>\n            \nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output shift_ena\n\nThis module is a part of the FSM for controlling a shift register, we\nwant the ability to enable the shift register for exactly 4 clock cycles\nwhenever the proper bit pattern is detected. Whenever the FSM is reset,\nassert shift_ena for 4 cycles, then 0 forever (until reset). Reset should\nbe active high synchronous.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.\n\n\n            </ORIGINAL_SPEC>\n\n            Please provide an improved version of the code that addresses these issues and correctly implements the specification!\n            \n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops and inputs to zero in simulation, unless provided the specified initial values in the question.s\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n\nPLEASE USE XML TAGS provided to enclose your response!\n \n            "
    },
    {
        "role": "assistant",
        "content": "<REASONING>\nTo implement the module `TopModule`, we need to create a finite state machine (FSM) that controls the `shift_ena` signal based on the clock and reset inputs. The FSM should assert `shift_ena` for exactly 4 clock cycles when a reset occurs and then keep it deasserted until the next reset.\n\n1. **Inputs and Outputs**: We have a clock (`clk`), a synchronous reset (`reset`), and an output (`shift_ena`). All are single-bit signals.\n\n2. **State Management**: We use a 3-bit counter (`cycle_count`) to keep track of the number of cycles for which `shift_ena` should be asserted. The counter is initialized to 4 on reset.\n\n3. **Reset Logic**: On a synchronous reset, the `cycle_count` is set to 4, and `shift_ena` is asserted. This ensures that `shift_ena` is high for the first 4 cycles after a reset.\n\n4. **Counting Logic**: If the `cycle_count` is not zero, it is decremented on each clock cycle, and `shift_ena` remains high. Once the counter reaches zero, `shift_ena` is deasserted.\n\n5. **Synchronous Operation**: The entire logic is synchronous with respect to the clock, and the reset is sampled on the clock's positive edge.\n\nThis approach ensures that `shift_ena` is asserted for exactly 4 cycles after a reset and remains deasserted until the next reset, as specified.\n</REASONING>\n\n<CODE>\n[BEGIN]\nmodule TopModule(\n    input logic clk,\n    input logic reset,\n    output logic shift_ena\n);\n\n    logic [2:0] cycle_count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            cycle_count <= 3'd4; // Initialize counter to 4 on reset\n            shift_ena <= 1'b1;   // Assert shift_ena on reset\n        end else if (cycle_count != 3'd0) begin\n            cycle_count <= cycle_count - 1; // Decrement counter\n            shift_ena <= 1'b1;              // Keep shift_ena high while counting\n        end else begin\n            shift_ena <= 1'b0;              // Deassert shift_ena when count is 0\n        end\n    end\n\nendmodule\n[DONE]\n</CODE>"
    }
]