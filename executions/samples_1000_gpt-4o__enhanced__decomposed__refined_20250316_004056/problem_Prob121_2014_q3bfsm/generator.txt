Generated Response:

<REASONING>
The implementation of the `TopModule` follows the guidelines and coding conventions provided. The module is designed to implement a finite-state machine (FSM) with a synchronous active-high reset. The FSM transitions between states based on the input `x` and outputs `z` according to the specified state table.

1. **Module Declaration**: The module is named `TopModule` with inputs `clk`, `reset`, `x`, and output `z`. All ports are declared as `logic` to adhere to the coding conventions.

2. **State Register**: The current state `state` and the next state `next_state` are declared as 3-bit `logic` vectors. This is necessary to represent the five possible states (000, 001, 010, 011, 100).

3. **State Transition Logic**: An `always` block is used to update the state on the positive edge of the clock. If `reset` is high, the state is set to 000. Otherwise, the state transitions to `next_state`.

4. **Next State and Output Logic**: Another `always @(*)` block is used to determine the `next_state` and output `z` based on the current `state` and input `x`. This block implements the state transition table and output logic provided in the specification.

5. **Default Case**: A default case is included to handle any unexpected states, ensuring the FSM returns to state 000 and outputs `z = 0`.

The implementation ensures that all logic is synchronous with the clock, and the reset is handled synchronously as specified.
</REASONING>

<CODE>
[BEGIN]
module TopModule (
    input logic clk,
    input logic reset,
    input logic x,
    output logic z
);

    logic [2:0] state, next_state;

    // State transition logic with synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    // Next state and output logic
    always @(*) begin
        case (state)
            3'b000: begin
                next_state = (x == 1'b0) ? 3'b000 : 3'b001;
                z = 1'b0;
            end
            3'b001: begin
                next_state = (x == 1'b0) ? 3'b001 : 3'b100;
                z = 1'b0;
            end
            3'b010: begin
                next_state = (x == 1'b0) ? 3'b010 : 3'b001;
                z = 1'b0;
            end
            3'b011: begin
                next_state = (x == 1'b0) ? 3'b001 : 3'b010;
                z = 1'b1;
            end
            3'b100: begin
                next_state = (x == 1'b0) ? 3'b011 : 3'b100;
                z = 1'b1;
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule
[DONE]
</CODE>

Generated Code:

module TopModule (
    input logic clk,
    input logic reset,
    input logic x,
    output logic z
);

    logic [2:0] state, next_state;

    // State transition logic with synchronous reset
    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
        end else begin
            state <= next_state;
        end
    end

    // Next state and output logic
    always @(*) begin
        case (state)
            3'b000: begin
                next_state = (x == 1'b0) ? 3'b000 : 3'b001;
                z = 1'b0;
            end
            3'b001: begin
                next_state = (x == 1'b0) ? 3'b001 : 3'b100;
                z = 1'b0;
            end
            3'b010: begin
                next_state = (x == 1'b0) ? 3'b010 : 3'b001;
                z = 1'b0;
            end
            3'b011: begin
                next_state = (x == 1'b0) ? 3'b001 : 3'b010;
                z = 1'b1;
            end
            3'b100: begin
                next_state = (x == 1'b0) ? 3'b011 : 3'b100;
                z = 1'b1;
            end
            default: begin
                next_state = 3'b000;
                z = 1'b0;
            end
        endcase
    end

endmodule