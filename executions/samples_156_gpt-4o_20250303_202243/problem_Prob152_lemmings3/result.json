{
    "code": "module TopModule (\n    input logic clk,         // Clock signal, positive edge-triggered\n    input logic areset,      // Asynchronous reset, active high\n    input logic bump_left,   // Input signal, Lemming hits an obstacle on the left\n    input logic bump_right,  // Input signal, Lemming hits an obstacle on the right\n    input logic ground,      // Input signal, indicates presence of ground\n    input logic dig,         // Input signal, command to dig\n    output logic walk_left,  // Output signal, Lemming walking left\n    output logic walk_right, // Output signal, Lemming walking right\n    output logic aaah,       // Output signal, Lemming falling\n    output logic digging     // Output signal, Lemming digging\n);\n\n    typedef enum logic [2:0] {\n        WL = 3'b000, // Walking Left\n        WR = 3'b001, // Walking Right\n        DL = 3'b010, // Digging Left\n        DR = 3'b011, // Digging Right\n        F  = 3'b100  // Falling\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (current_state)\n            WL: begin\n                if (!ground)\n                    next_state = F;\n                else if (dig)\n                    next_state = DL;\n                else if (bump_left)\n                    next_state = WR;\n                else\n                    next_state = WL;\n            end\n            WR: begin\n                if (!ground)\n                    next_state = F;\n                else if (dig)\n                    next_state = DR;\n                else if (bump_right)\n                    next_state = WL;\n                else\n                    next_state = WR;\n            end\n            DL, DR: begin\n                if (!ground)\n                    next_state = F;\n                else\n                    next_state = current_state;\n            end\n            F: begin\n                if (ground)\n                    next_state = (current_state == DL || current_state == WL) ? WL : WR;\n                else\n                    next_state = F;\n            end\n            default: next_state = WL;\n        endcase\n    end\n\n    // State Register\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= WL;\n        else\n            current_state <= next_state;\n    end\n\n    // Output Logic\n    always @(*) begin\n        walk_left = (current_state == WL || current_state == DL);\n        walk_right = (current_state == WR || current_state == DR);\n        aaah = (current_state == F);\n        digging = (current_state == DL || current_state == DR);\n    end\n\nendmodule",
    "test_results": {
        "num_mismatch": 0,
        "passfail": "e"
    }
}