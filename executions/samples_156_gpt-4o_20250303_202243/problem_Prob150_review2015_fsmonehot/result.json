{
    "code": "module TopModule (\n    input wire clk,                // Clock input for synchronous logic\n    input wire reset_n,            // Active-low reset input\n    input wire d,                  // 1-bit input\n    input wire done_counting,      // 1-bit input\n    input wire ack,                // 1-bit input\n    input wire [9:0] state,        // 10-bit input, one-hot encoded current state\n    output reg B3_next,            // 1-bit output\n    output reg S_next,             // 1-bit output\n    output reg S1_next,            // 1-bit output\n    output reg Count_next,         // 1-bit output\n    output reg Wait_next,          // 1-bit output\n    output reg done,               // 1-bit output\n    output reg counting,           // 1-bit output\n    output reg shift_ena           // 1-bit output\n);\n\n    // State encoding\n    localparam S    = 10'b0000000001;\n    localparam S1   = 10'b0000000010;\n    localparam S11  = 10'b0000000100;\n    localparam S110 = 10'b0000001000;\n    localparam B0   = 10'b0000010000;\n    localparam B1   = 10'b0000100000;\n    localparam B2   = 10'b0001000000;\n    localparam B3   = 10'b0010000000;\n    localparam Count = 10'b0100000000;\n    localparam Wait = 10'b1000000000;\n\n    reg [9:0] next_state;\n\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n            // Reset logic\n            next_state <= S;\n            B3_next <= 0;\n            S_next <= 0;\n            S1_next <= 0;\n            Count_next <= 0;\n            Wait_next <= 0;\n            done <= 0;\n            counting <= 0;\n            shift_ena <= 0;\n        end else begin\n            // State transition logic\n            case (state)\n                S: begin\n                    if (d == 0) next_state <= S;\n                    else next_state <= S1;\n                end\n                S1: begin\n                    if (d == 0) next_state <= S;\n                    else next_state <= S11;\n                end\n                S11: begin\n                    if (d == 0) next_state <= S110;\n                    else next_state <= S11;\n                end\n                S110: begin\n                    if (d == 0) next_state <= S;\n                    else next_state <= B0;\n                end\n                B0: next_state <= B1;\n                B1: next_state <= B2;\n                B2: next_state <= B3;\n                B3: next_state <= Count;\n                Count: begin\n                    if (done_counting == 0) next_state <= Count;\n                    else next_state <= Wait;\n                end\n                Wait: begin\n                    if (ack == 0) next_state <= Wait;\n                    else next_state <= S;\n                end\n                default: next_state <= S;\n            endcase\n\n            // Output logic\n            B3_next <= (next_state == B3);\n            S_next <= (next_state == S);\n            S1_next <= (next_state == S1);\n            Count_next <= (next_state == Count);\n            Wait_next <= (next_state == Wait);\n            shift_ena <= (state == B0) || (state == B1) || (state == B2) || (state == B3);\n            counting <= (state == Count);\n            done <= (state == Wait);\n        end\n    end\n\nendmodule",
    "test_results": {
        "num_mismatch": 300,
        "passfail": "r"
    }
}