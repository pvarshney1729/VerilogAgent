[
    {
        "role": "system",
        "content": "You are a Verilog RTL designer that only writes code using correct Verilog syntax."
    },
    {
        "role": "user",
        "content": "<Question>\nI would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n\n - input  predict_valid,\n - input  predict_pc (7 bits)\n - output predict_taken\n - output predict_history (7 bits)\n\n - input  train_valid\n - input  train_taken\n - input  train_mispredicted\n - input  train_history (7 bits)\n - input  train_pc (7 bits)\n\nThe module should implement a gshare branch predictor with 7-bit pc and\n7-bit global history, hashed (using xor) into a 7-bit index. This index\naccesses a 128-entry table of two-bit saturating counters. The branch\npredictor should contain a 7-bit global branch history register. The\nbranch predictor has two sets of interfaces: One for doing predictions\nand one for doing training. The prediction interface is used in the\nprocessor's Fetch stage to ask the branch predictor for branch direction\npredictions for the instructions being fetched. Once these branches\nproceed down the pipeline and are executed, the true outcomes of the\nbranches become known. The branch predictor is then trained using the\nactual branch direction outcomes.\n\nWhen a branch prediction is requested (predict_valid = 1) for a given pc,\nthe branch predictor produces the predicted branch direction and state of\nthe branch history register used to make the prediction. The branch\nhistory register is then updated (at the next positive clock edge) for\nthe predicted branch.\n\nWhen training for a branch is requested (train_valid = 1), the branch\npredictor is told the pc and branch history register value for the branch\nthat is being trained, as well as the actual branch outcome and whether\nthe branch was a misprediction (needing a pipeline flush). Update the\npattern history table (PHT) to train the branch predictor to predict this\nbranch more accurately next time. In addition, if the branch being\ntrained is mispredicted, also recover the branch history register to the\nstate immediately after the mispredicting branch completes execution.\n\nIf training for a misprediction and a prediction (for a different,\nyounger instruction) occurs in the same cycle, both operations will want\nto modify the branch history register. When this happens, training takes\nprecedence, because the branch being predicted will be discarded anyway.\nIf training and prediction of the same PHT entry happen at the same time,\nthe prediction sees the PHT state before training because training only\nmodifies the PHT at the next positive clock edge. The following timing\ndiagram shows the timing when training and predicting PHT entry 0 at the\nsame time. The training request at cycle 4 changes the PHT entry state in\ncycle 5, but the prediction request in cycle 4 outputs the PHT state at\ncycle 4, without considering the effect of the training request in cycle\n4. Reset is asynchronous active-high.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.\n</Question>\n\n\n\nThe following plan/guidelines might be useful for generating the correct Verilog code:\n<Guidelines>\n- Ensure synchronous reset is implemented as specified.\n- Initialize all flip-flops to zero in simulation.\n- Adhere strictly to the provided interface and signal names.\n- Generate results in the specified cycle timing.\n- Infer logic correctly, especially when using Karnaugh maps.\n- Handle bitwise operations and signal broadcasting correctly.\n</Guidelines>\n\nHere are some additional rules and coding conventions.\n<Coding Conventions>\n - Declare all ports and signals as logic; do not to use wire or reg.\n - For combinational logic with an always block do not explicitly specify\n   the sensitivity list; instead use always @(*).\n - All sized numeric constants must have a size greater than zero\n   (e.g, 0'b0 is not a valid expression).\n - An always block must read at least one signal otherwise it will never\n   be executed; use an assign statement instead of an always block in\n   situations where there is no need to read any signals.\n - if the module uses a synchronous reset signal, this means the reset\n   signal is sampled with respect to the clock. When implementing a\n   synchronous reset signal, do not include posedge reset in the\n   sensitivity list of any sequential always block.\n</Coding Conventions>\n\n<REASONING>\nYour reasoning behind your implementation here. Think step by step.\n</REASONING>\n\n<CODE>\nIMPORTANT: Enclose your code with [BEGIN] and [DONE] tags.\nDo NOT use Markdown code blocks (```) inside the [BEGIN]/[DONE] tags.\nYour code should look like:\n\n[BEGIN]\nmodule TopModule(\n    input in,\n    output out\n);\n    // Your implementation here\nendmodule\n[DONE]\n</CODE>\n"
    },
    {
        "role": "assistant",
        "content": "To implement your requested module, I have decomposed it into the following subtasks and come up with an approach for each:\n                    SUBTASK 1: Define the TopModule with the specified input and output ports.\nIMPLEMENTATION:\nmodule TopModule (\n    input clk,\n    input areset,\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken,\n    output [6:0] predict_history,\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    // Define the global history register\n    reg [6:0] global_history;\n\n    // Define the pattern history table (PHT) with 128 entries of 2-bit counters\n    reg [1:0] PHT [0:127];\n\n    // Calculate the index for the PHT using XOR of PC and global history\n    wire [6:0] predict_index = predict_pc ^ global_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n\n    // Predict taken based on the most significant bit of the PHT entry\n    assign predict_taken = PHT[predict_index][1];\n\n    // Output the current global history\n    assign predict_history = global_history;\n\n    // Sequential logic for updating the global history and PHT\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronous reset\n            global_history <= 7'b0;\n            integer i;\n            for (i = 0; i < 128; i = i + 1) begin\n                PHT[i] <= 2'b01; // Initialize PHT to weakly not taken\n            end\n        end else begin\n            if (train_valid) begin\n                // Update PHT based on training\n                if (train_taken) begin\n                    if (PHT[train_index] != 2'b11) begin\n                        PHT[train_index] <= PHT[train_index] + 1;\n                    end\n                end else begin\n                    if (PHT[train_index] != 2'b00) begin\n                        PHT[train_index] <= PHT[train_index] - 1;\n                    end\n                end\n\n                // Update global history if mispredicted\n                if (train_mispredicted) begin\n                    global_history <= {global_history[5:0], train_taken};\n                end\n            end else if (predict_valid) begin\n                // Update global history for prediction\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule\n\nSUBTASK 2: Implement the 7-bit global branch history register with asynchronous active-high reset.\nIMPLEMENTATION:\nmodule TopModule (\n    input clk,\n    input areset,\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken,\n    output reg [6:0] predict_history,\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    reg [6:0] global_branch_history;\n\n    // Asynchronous active-high reset for the global branch history register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_branch_history <= 7'b0;\n        end else if (train_valid && train_mispredicted) begin\n            // Recover the branch history register if misprediction occurs\n            global_branch_history <= train_history;\n        end else if (predict_valid) begin\n            // Update the branch history register for the predicted branch\n            global_branch_history <= {global_branch_history[5:0], predict_taken};\n        end\n    end\n\n    // Output the current state of the global branch history register\n    always @(*) begin\n        predict_history = global_branch_history;\n    end\n\n    // Additional logic for branch prediction and training would be implemented here\n\nendmodule\n\nSUBTASK 3: Implement the logic to hash the 7-bit PC and 7-bit global history using XOR to generate a 7-bit index.\nIMPLEMENTATION:\nmodule TopModule (\n    input clk,\n    input areset,\n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken,\n    output [6:0] predict_history,\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    reg [6:0] global_history;\n    reg [1:0] pht [0:127]; // 128-entry table of 2-bit saturating counters\n\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n\n    // Hashing logic using XOR to generate a 7-bit index\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Additional logic for prediction and training would be implemented here\n\nendmodule\n\nSUBTASK 4: Implement the 128-entry table of two-bit saturating counters.\nIMPLEMENTATION:\nmodule TopModule (\n    input clk,\n    input areset,\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken,\n    output reg [6:0] predict_history,\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    reg [1:0] PHT [0:127]; // 128-entry table of two-bit saturating counters\n    reg [6:0] global_history;\n\n    // Initialize PHT and global history on reset\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                PHT[i] <= 2'b01; // Weakly not taken\n            end\n        end else begin\n            if (train_valid) begin\n                // Training logic\n                integer index;\n                index = train_pc ^ train_history;\n                if (train_taken) begin\n                    if (PHT[index] < 2'b11) PHT[index] <= PHT[index] + 1;\n                end else begin\n                    if (PHT[index] > 2'b00) PHT[index] <= PHT[index] - 1;\n                end\n                if (train_mispredicted) begin\n                    global_history <= {global_history[5:0], train_taken};\n                end\n            end else if (predict_valid) begin\n                // Prediction logic\n                integer index;\n                index = predict_pc ^ global_history;\n                predict_taken <= (PHT[index] >= 2'b10);\n                predict_history <= global_history;\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule\n\nSUBTASK 5: Implement the prediction logic to output the predicted branch direction and state of the branch history register when predict_valid is high.\nIMPLEMENTATION:\n```verilog\n[BEGIN]\nreg [6:0] global_history;\nreg [1:0] pht [0:127]; // 128-entry table of 2-bit saturating counters\n\nwire [6:0] index;\nassign index = predict_pc ^ global_history;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        global_history <= 7'b0;\n    end else if (predict_valid && !train_valid) begin\n        // Update global history register for the predicted branch\n        global_history <= {global_history[5:0], predict_taken};\n    end else if (train_valid && train_mispredicted) begin\n        // Recover global history register to the state after mispredicting branch\n        global_history <= {train_history[5:0], train_taken};\n    end\nend\n\nassign predict_taken = (pht[index] >= 2'b10);\nassign predict_history = global_history;\n[END]\n```\n\nSUBTASK 6: Update the global branch history register at the next positive clock edge for the predicted branch when predict_valid is high.\nIMPLEMENTATION:\nreg [6:0] global_branch_history;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        global_branch_history <= 7'b0;\n    end else if (predict_valid) begin\n        // Update the global branch history register for the predicted branch\n        global_branch_history <= {global_branch_history[5:0], predict_taken};\n    end\nend\n\nSUBTASK 7: Implement the training logic to update the PHT based on the actual branch outcome when train_valid is high.\nIMPLEMENTATION:\nreg [1:0] PHT [0:127]; // 128-entry table of two-bit saturating counters\n\n// Training logic to update the PHT based on the actual branch outcome\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Reset all PHT entries to weakly not taken (01)\n        integer i;\n        for (i = 0; i < 128; i = i + 1) begin\n            PHT[i] <= 2'b01;\n        end\n    end else if (train_valid) begin\n        // Calculate the index using XOR of train_pc and train_history\n        wire [6:0] index = train_pc ^ train_history;\n        \n        // Update the PHT entry based on the actual branch outcome\n        if (train_taken) begin\n            // If the branch was taken, increment the counter (saturate at 11)\n            if (PHT[index] != 2'b11) begin\n                PHT[index] <= PHT[index] + 1;\n            end\n        end else begin\n            // If the branch was not taken, decrement the counter (saturate at 00)\n            if (PHT[index] != 2'b00) begin\n                PHT[index] <= PHT[index] - 1;\n            end\n        end\n    end\nend\n\nSUBTASK 8: Implement the logic to recover the branch history register to the state immediately after the mispredicting branch completes execution when train_mispredicted is high.\nIMPLEMENTATION:\nreg [6:0] branch_history_reg;\nreg [6:0] mispredicted_history;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        branch_history_reg <= 7'b0;\n    end else if (train_valid && train_mispredicted) begin\n        // Recover the branch history register to the state immediately after the mispredicting branch\n        branch_history_reg <= train_history;\n    end else if (predict_valid) begin\n        // Update the branch history register for the predicted branch\n        branch_history_reg <= {branch_history_reg[5:0], predict_taken};\n    end\nend\n\nSUBTASK 9: Ensure that training takes precedence over prediction when both occur in the same cycle.\nIMPLEMENTATION:\n```verilog\n[BEGIN]\nreg [6:0] global_history;\nreg [1:0] pht [0:127]; // 128-entry table of two-bit saturating counters\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        global_history <= 7'b0;\n    end else begin\n        if (train_valid && train_mispredicted) begin\n            // Training takes precedence over prediction\n            global_history <= {train_history[5:0], train_taken};\n        end else if (predict_valid) begin\n            // Update global history for prediction\n            global_history <= {global_history[5:0], predict_taken};\n        end\n    end\nend\n[END]\n```\n\nSUBTASK 10: Ensure that the prediction sees the PHT state before training when both occur in the same cycle.\nIMPLEMENTATION:\nreg [1:0] PHT [0:127]; // 128-entry table of two-bit saturating counters\nreg [6:0] global_history;\n\n// Logic to handle prediction and training in the same cycle\nwire [6:0] predict_index = predict_pc ^ global_history;\nwire [6:0] train_index = train_pc ^ train_history;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Reset logic for PHT and global history\n        integer i;\n        for (i = 0; i < 128; i = i + 1) begin\n            PHT[i] <= 2'b01; // Initialize to weakly taken\n        end\n        global_history <= 7'b0;\n    end else begin\n        if (train_valid) begin\n            // Update PHT for training\n            if (train_taken) begin\n                if (PHT[train_index] != 2'b11) begin\n                    PHT[train_index] <= PHT[train_index] + 1;\n                end\n            end else begin\n                if (PHT[train_index] != 2'b00) begin\n                    PHT[train_index] <= PHT[train_index] - 1;\n                end\n            end\n            // Update global history on misprediction\n            if (train_mispredicted) begin\n                global_history <= {global_history[5:0], train_taken};\n            end\n        end else if (predict_valid) begin\n            // Update global history for prediction\n            global_history <= {global_history[5:0], PHT[predict_index][1]};\n        end\n    end\nend\n\nassign predict_taken = PHT[predict_index][1];\nassign predict_history = global_history;\n                    "
    },
    {
        "role": "user",
        "content": "Okay, now please implement the module, ensuring syntactical and functional correctness. You can use your subtasks as hints to create a single, complete, and coherent Verilog module that satisfies the original specification."
    }
]